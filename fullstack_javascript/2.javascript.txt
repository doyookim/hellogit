# 변수와 상수

데이터를 저장할 수 있는 메모리 상의 공간

## #01. 전역 변수

프로그램의 어느 곳 에서나 식별할 수 있는 변수를 의미

### 1) 변수의 선언과 할당

#### 변수의 선언

- 컴퓨터 메모리(RAM)상에 데이터를 기록하기 위해 공간을 예약하고 그 공간을 식별할 수 있는 이름을 지정하는 처리로 이해할 수 있다.
- 변수 이름 앞에 **`var`** 키워드를 명시하고 변수 이름을 지정
- 하나의 구문은 세미콜론으로 끝나야 함.

```js
var 변수이름;
```

#### 값의 할당

- 선언된 변수에 대입연산자 `=`를 사용하여 값을 대입하는 처리를 **할당**이라고 한다.
- 항상 **오른쪽에서 왼쪽으로 대입**

```js
변수이름 = 값;
```

### 2) 선언과 할당의 통합

- 변수를 선언하면서 대입 연산자를 활용하여 값의 할당까지 한 라인에서 처리한다.

```js
var 변수이름 = 값;
```

### 3) 변수값 변경하기

- 한 번 값이 할당된 변수는 다른 값으로 새롭게 할당 가능

```js
var num = 100;
num = 200;
```


### 4) 변수이름 규칙

1. 영어, 숫자, 언더바(`_`), `$` 기호만 사용할 수 있다.
2. 첫 글자는 숫자로 시작할 수 없다.
    > 일반적으로 영어 소문자로 시작한다.
3. 두 개 이상의 단어를 결합하여 이름을 지정하는 경우
    1. **스네이크 표기법**: 띄어쓰기가 필요한 위치에서 언더바(`_`)를 사용.
        - 변수를 정의할 때는 잘 사용되지 않는다.
        > home + work ==> home_work
    2. **카멜 표기법**: 띄어쓰기가 필요한 위치의 첫 글자를 대문자로 변경.
        - **변수** 정의할 때를 포함하여 거의 대부분의 경우 일반적으로 사용한다.
        > home + work ==> homeWork

잘 알려지지 않은 규칙이지만 **UTF-8** 환경에서는 **한글도 사용할 수 있다.**


### 5) 변수의 재선언

- **`var`** 키워드를 사용하여 선언된 변수는 **중복 선언**이 가능
- 이후 뒤에서 공부할 **변수의 스코프(유효성 범위)** 도 무시된다.
- ***이러한 특성은 JS를 제외한 모든 프로그래밍 언어들의 규칙에는 위배되는 사항이므로 가급적 사용하지 않는 것이 좋다.***

> var 키워드를 사용을 자제하는 것이 좋다.


## #02. 지역변수

- ES6 버전에서 새로 추가된 변수 생성 방법.
- 대부분의 프로그래밍 언어에서 말하는 일반적인 변수의 생성 규칙을 따른다.

> 적극 사용을 권장함.

### 1) 변수 선언, 할당
#### 선언

- `let` 키워드를 사용하여 선언한다.

```js
let 변수이름;
```

#### 할당

- `var` 키워드를 사용한 전역 변수의 경우와 동일하다.

```js
변수이름 = 값;
```

### 2) 선언과 할당의 통합

- `var` 키워드의 경우와 동일한 규칙으로 선언과 할당을 한 행에 축약할 수 있다.

```js
let 변수이름 = 값;
```


### 3) 중복 선언 금지

- **`let`** 키워드를 사용하여 선언된 변수는 중복 선언 불가능.
- `let` 키워드를 통해 생성된 변수는 **일반적인 프로그래밍 언어의 규칙을 모두 따른다.**

## #03. 상수

- 최초로 값을 할당한 이후 값을 변경할 수 없는 형태. (=읽기전용)
- **`const`** 키워드를 사용
- **선언과 동시에 값이 할당**되어야 함.
- 상수의 이름은 대문자만으로 구성된 스네이크 표기법을 사용하여 생성하는 것이 일반적.


## #04. 변수의 자료형 (데이터 타입)

### 1) 변수에 저장할 수 있는 값의 종류

자바스크립트의 데이터 타입은 변수에 값을 할당(대입)할 때 결정된다.

| 타입      | 설명                                                                                  |
| --------- | ------------------------------------------------------------------------------------- |
| number    | 정수와 실수를 포함하는 모든 숫자 형태                                                 |
| string    | 문자열. 쌍따옴표나 홑따옴표의 쌍으로 감싼 모든 형식의 데이터                          |
| boolean   | 논리형. true(참) 혹은 false(거짓)                                                     |
| object    | 객체. 함수(Function), 배열 (Array), 날짜 (Date), 정규식 (RegExp) 등을 포함한다        |
| null      | object 형의 한 종류. 나중에 할당하기 위해 임의로 비워 놓은 상태를 의미하는 특수한 값. |
| undefined | 정의되지 않음. 선언만 하고 값이 할당되지 않은 상태                                    |

### 2) 변수의 자료형 확인하기

- `typeof` 연산자는 피연산자의 평가 전 자료형을 나타내는 문자열을 반환한다.

```js
let a = 100;
console.log(typeof a);
```

# 03-연산자

변수를 활용하여 각종 연산을 수행하는데 사용되는 특수 기호

## #01. 산술연산자(사칙연산자)

일반적인 덧셈, 뺄셈, 곱셈, 나눗셈에 사용되는 기호

### 1) 산술연산자의 종류

| 연산자 | 설명                                        |
| ------ | ------------------------------------------- |
| +      | 덧셈                                        |
| -      | 뺄셈                                        |
| *      | 곱셈                                        |
| /      | 나눗셈                                      |
| %      | 나눗셈에서의 정수 부분의 몫을 제외한 나머지 |

### 2) 연산자의 활용

- `console.log()` 명령을 통해 변수간의 연산 결과를 출력
- 연산 결과를 새로운 변수에 할당

### 3) 나눗셈에서의 주의사항

| 케이스                      | 설명                                                                |
| --------------------------- | ------------------------------------------------------------------- |
| 일반적인 나눗셈             | 몫이 소수점까지 갖는 경우 연산할 수 있는 최대한의 자리수까지 계산함 |
| 나누어 떨어지지 않는 나눗셈 | 처리 가능한 범위 안에서 최대한의 소수점 자리수까지 계산함.          |


### 4) 문자열의 연산

| 케이스                    | 설명                                                                                                     |
| ------------------------- | -------------------------------------------------------------------------------------------------------- |
| 문자열 끼리의 덧셈        | 문자열을 하나로 병합하는 효과가 있다.                                                                    |
| 문자열과 다른 타입의 덧셈 | 문자열 이외의 값들을 모두 문자열로 취급하여 덧셈을 수행한다. 즉, 문자열끼리의 연결과 같은 결과를 갖는다. |


## #02. 대입 연산자.

좌변에 우변을 대입한다는 의미의 `=` 연산자.

이미 앞에서 많이 사용한 기호이다.

### 활용 방법
1. 연산 결과를 새로운 변수에 대입
1. 이미 생성된 변수의 값을 다른 값으로 변경
1. 연산 결과를 변수 스스로에게 덮어 씌우기
  - 어떤 변수 x에 대한 연산 결과를 다시 x에 덮어 씌울 수 있다.


## #03. 단항 연산자

- 어떤 변수 `x`에 대한 연산 결과를 다시 `x`에 덮어 씌우는 연산을 축약한 표현
- `+=`, `-=`, `*=`, `/=`, `%=`

## #04. 증감연산자

### 1) 스스로 1 증가 혹은 감소

- 단항 연산자를 덧셈과 뺄셈에 한하여 축약한 형태.
- 스스로 1증가 혹은 1감소로 해석할 수 있다.

### 2) 증감 연산자의 위치

- `++`, `--` 연산자가 독립적으로 사용되는 경우는 위치에 상관 없이 결과가 동일하지만, 다른 수식에 포함된 상태로 사용되는 경우 위치에 따라 결과값이 달라진다.

#### 전위 증감 연산자

- 연산자가 앞에 위치한 경우 (앞북)
- 증감연산자가 앞에 위치한 경우 변수 스스로의 값에 대해 증가, 감소를 먼저 수행한 후 전체 수식을 연산한다.

#### 후위 증감 연산자

- 연산자가 뒤에 위치한 경우 (뒷북)
- 변수에 대한 증감연산자가 작용하기 전에 전체 수식을 먼저 처리한 다음 나중에서야 증감 연산자가 수행된다.


## #05. 비교 연산자

- 두 값간의 크기를 비교하는 식에 대한 **참**, **거짓**을 판별한다.
- 비교 연산의 결과는 논리값(`true` 혹은 `false`)로 결정된다.

### 1) 이상(`>=`), 초과(`>`), 이하(`<=`), 미만(`<`)

- 초등학교에서 배우는 부등식

### 2) 같다(`==`, `===`), 다르다(`!=`, `!==`)

- `==`, `!=` : 값의 내용만 비교하기 때문에 문자열 1(`"1"`)과 숫자형 1(`1`)을 같다고 판단한다.
- `===`, `!==` : 값의 데이터 타입까지도 일치해야만 같다고 판단하기 때문에 문자열 1(`"1"`)과 숫자형 1(`1`)을 다르다고 판단한다.
- Javascript에서 `1 === 1.0` 은 정수와 실수를 구분하지 않고 모두 number 타입으로 처리하기 때문에 `true` 로 판단한다.


## #06. 논리 연산자

두 개의 논리값(`true` 혹은 `false`)간에 AND(`&&`), OR(`||`) 연산을 수행한다.

| 연산자    | 설명                                                                                                             |
| --------- | ---------------------------------------------------------------------------------------------------------------- |
| AND (**`&&`**) | 연산에 사용되는 모든 값이 `true`인 경우만 결과가 `true`이고 그 외의 경우는 모든 결과가 `false`           |
| OR (**`\|\|`**)  | 연산에 사용되는 값중에서 하나라도 `true`라면 결과가 `true`이고 모든 값이 `false`인 경우만 결과가 `false` |
| NOT (**`!`**)  | 느낌표 `!`를 사용하여 논리형 값 true, false를 부정하여 반대의 결과를 만들어 내는 연산자.                         |

### 파이프

<img src="res/pipe.png" width="150" />

### 특이사항

- AND가 OR보다 항상 우선한다.
- 숫자 값에 적용할 경우 `0`은 false으로 식별되고 `0`이 아닌 모든 수는 true로 식별된다.
- 문자열에 적용할 경우 빈 문자열(`""`)은 false로 식별되고 한 글자라도 포함된 문자열은 true로 식별된다.


## #07. 삼항 연산자 `? :`

```js
let 변수 = 조건식 ? 값1 : 값2;
```

조건식을 판별하여 식이 참인 경우 `값1`이 변수에 대입되고, 조건식이 거짓인 경우 `값2`가 변수에 대입되는 연산자.

const numOfApples = 123;
let basket = numOfApples / 10 ;
console.log(basket);
if (basket >= 10)
{
    ++basket 
}
console.group("문제3");
console.log("바구니는 총 %d개가 필요합니다.",parseInt(basket));
console.groupEnd();



// 사과의 수

const numOfApples = 123;

// 10으로 나눈 나머지를 소수점 값으로 환산
const extra = (numOfApples % 10) / 10;
console.log(extra);

//첫번째 풀이
let basketCount = numOfApples / 10;
console.log(basketCount);
let basketCount = extra > 0 ? (numOfApples / 10) - extra + 1 : (numOfApples / 10) - extra;
console.log(basketCount);

// 두번째 풀이
let basketCount = (numOfApples / 10)  - extra;
basketCount += extra > 0? 1: 0;
console.log(basketCount);


# 04-프로그램_흐름제어

프로그램 구문이 무조건 순차적으로 실행되는 것이 아니라 주어진 조건을 판별하여 선택적 혹은 반복적으로 실행 여부를 결정하도록 흐름을 제어하는 코드 작성 기법

## #01. 조건문

### 1) if문

주어진 조건식이 참인 경우에만 블록(`{}`)안을 실행하는 구문 형태.

```js
if (조건식) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

#### a) 조건식에 따른 구분

#####  논리값을 사용한 경우

`true`나 `false`를 저장하고 있는 변수를 조건으로 지정한다.

```js
const a = true;

// 주어진 조건이 참이므로 블록을 실행함.
if (a) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

```js
const b = false;

// 주어진 조건이 거짓이므로 블록을 실행하지 않음
if (b) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

##### 숫자형 값을 사용한 경우

숫자형인 경우 0은 거짓, 0이 아닌 모든 수는 참으로 식별한다.

```js
const a = 123;

// 주어진 조건이 참이므로 블록을 실행함.
if (a) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

```js
const b = 0;

// 주어진 조건이 거짓이므로 블록을 실행하지 않음
if (b) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

##### 문자열 값을 사용한 경우

빈 문자열 `""`은 `false`, 내용이 한 글자라도 포함된 문자열은 `true`로 식별한다.

문자열 변수를 조건으로 사용하는 경우는 **문자열에 내용이 포함되어 있다면?** 으로 해석할 수 있다.

```js
const a = "hello";

// 주어진 조건이 참이므로 블록을 실행함.
if (a) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

```js
const b = "";

// 주어진 조건이 거짓이므로 블록을 실행하지 않음
if (b) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

##### 비교식을 사용한 조건문

`()` 안의 식이 참인 경우 `{}` 안의 구문이 실행된다.

```js
const a = 100 > 10;

// 주어진 조건이 참이므로 블록을 실행함.
if (a) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

```js
// 주어진 조건이 거짓이므로 블록을 실행하지 않음
if (100 < 10) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

##### 논리식을 사용한 조건문

AND(`&&`) 연산모든 값이 `TRUE`인 경우에만 결과가 `TRUE`

```js
let a = true;
let b = true;
// 주어진 조건이 참이므로 블록을 실행함.
if (a && b) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

```js
let c = true;
let d = false;
// 주어진 조건이 거짓이므로 블록을 실행하지 않음
if (c && d) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

OR(`||`) 연산은 하나라도 `참`이 포함되어 있다면 결과가 `참`

```js
let a = true;
let b = false;
// 주어진 조건이 참이므로 블록을 실행함.
if (a || b) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

```js
let c = false;
let d = false;
// 주어진 조건이 거짓이므로 블록을 실행하지 않음
if (c || d) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

`!` 연산자는 논리값을 부정한다.

```js
let a = false;
// 주어진 조건이 참이므로 블록을 실행함.
if (!a) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

```js
let b = true
// 주어진 조건이 거짓이므로 블록을 실행하지 않음
if (!b) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

문자열도 `true`, `false`를 판단할 수 있으므로 `!`로 처리 가능하다.

문자열에 대해 not 연산자를 적용할 경우 **내용이 없다면?** 으로 해석할 수 있다.

```js
let a = "";
// 주어진 조건이 참이므로 블록을 실행함.
if (!a) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```

```js
let b = "...";
// 주어진 조건이 거짓이므로 블록을 실행하지 않음
if (!b) {
    ... 조건이 참인 경우에 실행할 명령 ...
}
```


#### b) if ~ else 문

그렇지 않으면~~

```js
if (조건식) {
    ... 조건이 참인 경우에 실행할 명령 ...
} else {
    ... 조건이 참이 아닌 경우에 실행할 명령 ...
}
```

- if문은 조건이 참인 경우에만 수행되고 조건이 거짓인 경우는 수행되지 않는다.
- if문 뒤에 else문을 덧붙여 조건이 거짓인 경우에 수행되는 구문을 추가할 수 있다.
- else문은 if문 뒤에만 위치할 수 있고 독립적으로는 존재할 수 없다.

#### c) if ~ else if ~ else 문

여러가지 경우의 수를 나열하는 조건문.

순차적으로 조건을 판별하면서 **가장 처음 만나는 `참`인 조건의 블록을 수행**하고 빠져나간다.

```js
if (조건식1) {
    ... 조건이 참인 경우에 실행할 명령 ...
} else if (조건식2) {
    ... 조건이 참인 경우에 실행할 명령 ...
} else if (조건식3) {
    ... 조건이 참인 경우에 실행할 명령 ...
} else if (조건식n) {
    ... 조건이 참인 경우에 실행할 명령 ...
} else {
    ... 조건이 참이 아닌 경우에 실행할 명령 ...
}
```

### 2) switch 문

#### 기본 구문

하나의 변수나 수식에 대한 여러가지 경우의 수를 나열하는 형식.

조건에 맞는 `case` 블록부터 `break` 키워드를 만날 때 까지 실행한다.

switch의 조건을 식으로 설정하는 것도 가능하다.

마지막의 default는 모든 케이스를 충족하지 않을 경우 실행되고, 필요 없다면 생략할 수 있다.

```js
switch (변수) {
    case 1:
        ... 실행할 명령 ...
        break;
    case 2:
        ... 실행할 명령 ...
        break;
    case n:
        ... 실행할 명령 ...
        break;
    default:
        ... 실행할 명령 ...
        break;
}
```

#### `break`가 없는 경우

중단점이 없기 때문에 그 아래 블록까지 함께 실행된다.

필요에 따라 의도적으로 `break`의 위치를 조절 할 수 있다.


## #02. 반복문

### 1) while문

#### a) while문의 구문 형식

주어진 조건이 참을 충족하는 동안 수행되는 문법

```jsx
초기식
while (조건식) {
    ... 반복적으로 수행될 구문 ...
    증감식
}
```

##### 실행과정

- 초기식, 조건식, 증감식의 요소를 충족해야 성립된다.
- `{}` 안에서 선언되는 변수나 상수는 그 블록 안에서만 유효하다.
- 반복문 `{}` 안에서 선언되는 변수나 상수는 그 회차에서만 유효하고 새로운 회차의 반복에서는 기존 변수는 삭제되고 새롭게 생성된다.

#### b) 증가량 조절하기

- 증감식을 조절하여 증가량을 조절할 수 있다.
- ex) `0`부터 `100`전(=99)까지 `**10씩 증가**`하기


### 2) For문

#### a) For문의 구문 형식

초기식, 조건식, 증감식이 하나의 괄호`()` 안에 모두 명시되는 형태.

```jsx
for (초기식; 조건식; 증감식) {
    ...
}
```

###### 실행과정

1. 초기식을 실행한다.
2. 조건식을 판별한다.
    - 조건식이 참인 경우 `{}`안을 1회 실행하고 증감식으로 이동한다.
        - 증감식을 실행한 후 다시 조건식으로 이동한다.
    - 조건식이 거짓인 경우 `{}` 블록을 실행하지 않고 빠져나간다.


/** 구구단 7단 출력하기 */
// y가 1부터 10보다 작은 동안 1씩 증가하면서 반복하므로 반복의 범위는 1~9
// 반복문이 수행되는 동안 y값에 7을 곱해서 z값을 생성

let y = 1;

while ( y <  10) {
    const z = y * 7;
    console.log("7 x %d = %d", y, z);
    y++;
}
// 누적합을 구하기 위해서는 반복이 시작되기 전, 합산에 사용할 변수를 0으로 초기화 해 놓고 반복문 안에서 누적 합산을 수행한다.
let x = 0;                          // 합계를 구하기 위한 변수
let i = 1;                          // 초기식

while (i <= 10) {                   // 조건식 --> i의 범위 : 1~10
    x += i;                         // x부터 1부터 10까지 반복하면서 합산한다.
    console.log("i=%d, x=%d", i, x);
    i++;                            // 증감식
}

console.log("1부터 10까지의 합: " + x);


// y가 1부터 10보다 작은 동안 1씩 증가 --> y의 범위: 1~9

for (let y=1; y < 10; y++) {
    const z = y * 7;
    console.log("7 X %d = %d", y, z);
}

// 합계를 구하기 위해서는 반복문 집인 전 0으로 초기화 된 변수가 필요하다.
// 이 변수에 합계 대상값들을 누적합산한다.
let x = 0;

// i가 1부터 10이하인 동안 1씩 증가 --> i의 범위 : 1~10
for (let i = 1; i <= 10; i++) {
    // 미리 준비한 변수에 i를 합산
    x += i;
    console.log("i=%d, x=%d", i, x);
}

console.log("1부터 10까지의 합: " + x);


// a가 0부터 100보다 작은 동안 10씩 증가
for (let a=0; a < 100; a+=10) {
    console.log("a=%d", a);
}


// b가 10부터 0보다 큰 동안 2씩 감소
for (let b=10; b > 0; b-=2) {
    console.log("b=%d", b);
}




const 수학 = "B";

// 강사님 답안
if (수학 == "A" || 수학 == "B" || 수학 == "C") {
    console.log("이 과목을 Pass 했습니다.");
} else {
    console.log("이 과목을 Pass하지 못했습니다.");
}



let bit = 1;         // 누적된 곱셈에 대한 초기갑은 1부터 시작
let i = 1;           // 초기식

while ( i <= 10 ) {  // 조건식
   bit *= 2;
   console.log('이진수 %d개는 %d개의 정보를 표시가능', i, bit);
   i++;              // 증감식
}




let bit = 1;

for ( let i = 1; i <= 10; i++){
    bit *=2;
    console.log('이진수 %d개는 %d개의 정보를 표시가능', i, bit);
}


# 기본문법 활용하기

조건문, 반복문을 구성하는 <U>블록 `{}`</U> 안에 <U>다른 문법 표현이 포함될 수 있다.</U> 이러한 규칙으로 다양한 문법 중첩 패턴이 생기는데 이 중에서 자주 사용되는 패턴으로는 `if-if`, `if-for`, `for-if`, `for-for`가 있습니다.

---

## #01. 변수의 유효성 범위 (변수의 스코프)

### 1) **var** 키워드로 선언된 변수의 경우

블록 '{}' 안에서 선언된 변수는 블록의 실행 여부에 따라 블록 밖에서의 식별 여부가 결정됨.

블록 '{}'을 갖는 부분이 실행되지 않을 경우 블록 안에서 선언된 변수를 블록 밖에서 사용할 경우 할당되지 않은 undefined가 됨

### 2) **let** 키워드로 선언된 변수와 **const** 키워드로 선언된 상수의 경우

<U>블록 밖에서 선언된 변수는 블록 안으로 침투할 수 있지만</U> 블록 안에서 선언된 변수는 블록을 빠져나올 수 없음.

변수의 범위가 블록안으로 한정되므로 서로 다른 블록끼리는 중복 선언 가능


### 3) for문의 <U>초기식에 대한 유효성 범위</U>

**var** 키워드를 사용한 경우에는 <U>초기식에서 선언된 변수가 for문 밖에서 식별 가능함.</U>

**let** 키워드를 사용한 경우에는 <U>초기식에서 선언된 변수는 for문 밖에서 식별 할 수 없음.</U>

let 키워드는 반드시 선언-> 할당의 순서로만 사용 가능함.\
var 키워드는 할당 후 선언이 가능함.

## #02. if문 안에 포함된 흐름제어

### 1) if-if구조

특정 조건이 참으로 판단되어 블록안에 진입했을 때, 상세조건을 판별하는 구조.

```js
if (조건) {
    if (조건) {
        ...
    }
} else if (조건) {
    if (조건) {
        ...   
    } else {
        ...
    }
} else {
    if (조건) {
        ...
    } else if (조건) {
        ...
    } else {
        ...
    }
}
```

### 2) if-for 구조

특정 조건이 참으로 판단되어 블록안에 진입했을 때, 반복을 수행하는 구조.

```js
if (조건) {
    for (초기식; 조건식; 증감식) {
        ...
    }
}
```


---


## #03. for문 안에서의 흐름제어

### 1) 반복문 안에서의 조건문

반복문 안에서 매 반복 수행시마다 조건을 판별한다. 

주로 반복문에 사용되는 조건값(=초기식에서 생성한 변수)에 대한 조건 판별을 위해 사용된다.


### 2) For문 안의 For문

바깥의 반복문(부모)이 1회 수행할 때 마다 안쪽의 반복문(자식)이 매번 처음부터 새로 시작하는 이중 반복문 구조.

두 반복문간의 조건값이 서로 달라야 한다.

### 3) 반복범위 동적설정

자식 반복문의 조건식이 부모 반복문의 조건변수를 활용하여 구성되면 자식 반복문의 반복 범위에 변화를 줄 수 있다.

### 4) 반복문 안에서의 흐름 제어

#### 무한루프

절대로 조건식이 종료되지 않는 형태의 반복문.

```jsx
while (true) {           // 무조건 반복. 종료되지 않는다 (무한루프)
    ...
}
```

#### 반복문 제어하기

반복을 몇 번 수행해야 하는지 판단할 수 없는 경우 무한루프 형태로 지정하고 특정 조건이 충족되는지에 따라 반복의 중단 여부를 결정한다.

반복문의 흐름제어 기능을 갖는 키워드

- `continue`: 조건식으로 강제 이동
- `break`: 현재 반복문을 강제로 종료하고 블록을 빠져 나간다.




/** 이중 반복문 구구단 */

 for (let i=2; i<10; i++){
    
    console.group("%d단", i);

    for (let j=1; j<10; j++) {
        console.log("%d x %d = %d", i, j, i*j);
    }

    console.groupEnd();
 }
 
 
 
 /** 별찍기 */
/*
- i가 0일때 1회를 수행하기 위해서 'j < 1'
- i가 1일때 2회를 수행하기 위해서 'j < 2'
- i가 2일때 3회를 수행하기 위해서 'j < 3'
- i가 3일때 4회를 수행하기 위해서 'j < 4'
- i가 n일때 i+1회를 수행하기 위해서 'j < i+1'
*/

for (let i=0; i<7; i++) {       // 바깥의 반복문이 "행"을 담당 --> 7개의 행이 생성된다.

    let str = "";

    for (let j=0; j<i+1; j++) { // 안쪽의 반복문이 "열"을 담당
        str += "*";
    }

    console.log(str);
}




/** 별찍기 */
/*
- i가 0일때 7회를 수행하기 위해서 'j < 7'
- i가 1일때 6회를 수행하기 위해서 'j < 6'
- i가 2일때 5회를 수행하기 위해서 'j < 5'
- i가 3일때 4회를 수행하기 위해서 'j < 4'
- i가 n일때 7-i회를 수행하기 위해서 'j < 7-i'
*/

for (let i=0; i<7; i++) {       // 바깥의 반복문이 "행"을 담당 --> 7개의 행이 생성된다.

    let str = "";
    //console.log(str);
    for (let j=0; j<7-i; j++) { // 안쪽의 반복문이 "열"을 담당
        //console.log(str);
        str += "*";
        //console.log(str);
    }

    console.log(str);
}




///for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오.
/** [풀이01] */
for ( let i=9; i > -1; i --) {
    if ( i % 2 == 1 ) {
        console.log(i);
    }
}
/** [풀이02] */
for (let i=9; i > -1; i-=2) {
    console.log(i);
}



// while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오.
 /** [풀이01] */
let i=9;

while (i > -1) {
    if ( i % 2 == 1) {
        console.log(i);
    }
    i--;
}

/** [풀이02] */
let j = 9;

while ( j > -1 ){
    console.log(j);
    j -= 2;
}





//1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오.

// 변수의 초기와 - 최초로 값을 할당하는 처리를 의미

// 합계를 구하기 위해서는 0으로 초기화 된 변수가 필요함.

let sum = 0;

for (let i=1; i<20; i++) {
    if (i % 2 == 0 || i % 3 == 0) {
        sum += i;
    }
}

console.log(sum);





// 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하고 
// 경우의 수는 총 몇가지 인지를 아래와 같이 출력하는 코드를 작성하시오.
 let count = 0;

// 첫 번째 주사위의 반복
for (let i=1; i<6; i++) {
    // 두 번째 주사위의 반복
    for (let j=1; j<=6; j++) {
        if (i + j == 6) {
            console.log("[%d, %d]", i, j);

            // 조건이 충족될때 마다 1씩 증가 -->
            count++;
        }
        
    }
}

console.log("경우의 수는 %d개 입니다.", count);


// for문을 중첩하여 실행하여 아래와 같은 출력 결과를 만드시오.
 
 for (let i=0; i<4; i++) {
    
    // 한 줄에 출력할 문자열 변수
    let str = "";

    for (let j=0; j<4; j++) {
        str += i+j;

        if (j+1 < 4) {
            str += " ";
        }
    }

    console.log(str);
}



for (let i=0; i<7; i++) {
    let str = "";

    for (let j=0; j<i+1; j++) {
        str += j+1;
    }
    console.log(str);
}



/**
  number라는 변수를 정의하고 1 혹은 2의 값을 임의로 할당하시오. 이 변수에는 1이나 2밖에 저장될 수 없습니다.

구구단 프로그램을 만들고자 한다.

전체를 출력하는 구구단이 아니라 number가 1일 때는 홀수 단(3, 5, 7, 9), number가 2일 때는 입력하면 짝수 단(2, 4, 6, 8)을 출력하는 프로그램을 완성하시오.
 */

// [풀이1]

const number = 2;

for (let i=2; i<10; i++) {
    if (number == 1) {
        if (i % 2 != 0) {
            for (let j=1; j<10; j++) {
                console.log("%d x %d = %d", i, j, i*j);
            }
        }
    } else {
        if (i % 2 == 0) {
            for (let j=1; j<10; j++) {
                console.log("%d x %d = %d", i, j, i*j);
            }
        }
    }
}


// [풀이2]

//const number = 2;
 const number =1;

let start = number == 2 ? 2 : 3;

for (let i=start; i<10; i+=2) {
    for (let j=1; j<10; j++) {
        console.log("%d x %d = %d", i, j, i*j);
    }
}


// [풀이3]

const number = 2;
// const number =1;

for (let i=4-number; i<10; i+=2) {
    for (let j=1; j<10; j++) {
        console.log("%d x %d = %d", i, j, i*j);
    }
}



# 배열

## #01. 배열의 이해

### 1) 배열의 필요성

학급의 성적표를 보고 각 학생별로 총점과 평균을 구해야 한다고 가정할 때,

| 이름 | 국어 | 영어 | 수학 |
|---|---|---|---|
| 철수 | 92 | 81 | 77 |
| 영희 | 72 | 95 | 98 |
| 민혁 | 80 | 86 | 84 |

성적표가 아래와 같다면 3명씩 3과목이므로 총 9개의 변수가 필요할 것이다.

(자료구조) 


```jsx
var kor1 = 92;
var kor2 = 71;
var kor3 = 80;
// ... 생략 ...
var math2 = 84;
var math3 = 98;
```

만약 30명의 학생에 대한 20과목에 대한 점수라고 가정한다면 생성해야 하는 변수가 더 증가하므로 프로그램은 좀 더 복잡해 질 것이다.

배열은 이러한 경우를 해소하기 위한 자바스크립트 자료구조의 하나로, 변수에 여러 개의 데이터를 그룹화해서 저장해 놓은 상태를 말한다.

### 2) 배열 생성하기

#### 배열의 선언

Javascript는 변수의 특성이 <U>값이 할당 될 때</U> 결정되기 때문에 선언은 일반 변수와 동일하다.

즉, 할당하기 전까지는 숫자, 문자열, 배열 등의 구분이 없다.

```jsx
let myArr;
```

#### 배열의 할당

<U>대괄호(`[]`)안에</U> 포함할 값들을 <U>데이터 타입의 구분 없이</U> 콤마(`,`)로 구분하여 나열한다.

선언과 할당이 나누어져 있는 경우 <U>`const` 로 선언할 수 없다.</U>

myArr = [1, 2, 3.14, true, false, "hello", "world"];

#### 선언과 할당의 통합

```js
let myArr = [1, 2, 3, 5, 7];
```

#### Array 클래스를 사용한 할당

`new Array(...)` 형식으로 생성한다.

```js
let newArr1 = new Array("hello", "world", 1, 2, 3, true, false);
```

| 클래스는 아직 소개되지 않은 개념이므로 여기서는 명령어의 일종으로 받아들이시기 바랍니다.

#### Array 클래스 사용시 주의할 점

<U>`new Array()`로 배열을 생성할 때 `()`안에 숫자 값 하나만 명시되는 경우, 숫자 값 만큼의 빈 칸을 갖는 배열이 생성된다.</U>

배열의 각 칸은 모두 정의되지 않은 값(**undefined**)로 할당된다.


### 3) 배열의 원소에 접근하기

배열의 각 원소는 <U>0부터 시작하는 일련번호를 부여 받는데, 이를 배열의 **인덱스** 라고 한다.</U>

배열의 원소에 접근할 때는 인덱스 번호를 활용하여 접근해야 한다.

```jsx
let myArr = [1, 2, 3.14, true, false, "hello", "world"];
console.log(myArr[0]);
console.log(myArr[2]);
console.log(myArr[4]);
console.log(myArr[6]);
```

존재하지 않는 원소의 값을 출력하고자 할 경우, 정의되어 있지 않으므로 **undefined**가 된다.

### 4) 배열의 크기

<U>`배열이름.length`는 배열의 칸 수를 반환한다.</U>

<U>배열의 인덱스는 항상 `0`부터 `크기-1`까지 1씩 증가하면서 존재한다.</U>

### 5) 반복문을 통한 활용

<U>배열은 인덱스가 0부터 1씩 배열의 길이보다 작은 동안 순차적으로 증가한다는 특성</U>이 있다.

<U>반복문의 초기식을 0으로, 조건식을 길이보다 작은 동안, 증감식을 1씩 증가로 설정한 반복문과 함께 사용하는 것이 일반적이다.</U>

이와 관련하여 다양한 예제 패턴들이 존재한다.

> ### 추가 설명

반복문을 이용하여 배열의 모든 요소를 출력해보자.


### 세팅
```javascript
const fruits = ['apple', 'banana', 'kiwi', 'melon'];
```


### for
```javascript
for (let i = 0; i < fruits.length; i++) {
  console.log(fruits[i]);
}
```

### for of
```javascript
for (let fruit of fruits) {
  console.log(fruit);
}
```

### forEach
> 배열의 값마다 내가 전달한 함수를 적용해준다.
```javascript
fruits.forEach(function (fruit, index, array) {
  console.log(fruit, index, array);
});
```
forEach를 사용할 때는 콜백함수를 사용하는데 콜백함수의 인자로 (값, 인덱스, 배열) 로 정의하여 사용한다.


위 함수를 화살표 함수로 좀더 축약해보자.
```javascript
fruits.forEach((fruit, index, array) => console.log(fruit, index, array));
```
fruits이라는 배열의 값을 fruit에 담고 각각의 인덱스를 index에 담아서 출력한다.

> 출처: https://velog.io/@younoah/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B0%B0%EC%97%B4-%EC%B4%9D%EC%A0%95%EB%A6%AC

## #02. 2차 배열

<U>1차 배열의 각 원소가 다른 배열로 구성된 형태.</U>

**열**의 개념만 존재하는 1차 배열에 **행**의 개념을 추가한 형태가 2차 배열 이다.

### 1) 2차 배열 생성하기

`[]`를 사용하여 1차원을 표현하고 그 안에 다시 `[]`를 콤마로 구분하여 2차원을 구성한다.

```js
const myarr = [ [ ... ], [...] ]
```

### 2) 2차 배열의 원소에 접근하기

2행 3열인 경우 행의 인덱스는 0부터 1까지, 열의 인덱스는 0부터 2까지 존재한다.

배열에 저장된 원소에 접근하기 위해서는 <U>변수이름 뒤에 행, 열의 순서로 인덱스를 명시한다.</U>

### 3) 2차 배열의 행, 열 크기 구하기

#### 행의 크기

2차 배열에 대한 길이를 직접 구하면 행의 크기를 알 수 있다.

#### 열의 크기

2차 배열의 모든 행에 대한 열 크기가 항상 동일하다는 보장이 없기 때문에 열의 크기는 각 행마다 개별적으로 구해야 한다.

### 4) 가변배열

2차 배열의 정확한 개념은 1차 배열의 각 원소가 다른 배열로 구성된 형태이다. 

원소로서 포함되는 각 배열의 크기가 동일하지 않은 경우를 가변 배열이라고 한다.

항상 배열의 모든 행이 동일한 열로 구성되는 것은 아니다. (모든 줄의 칸 수가 같다는 보장은 없다는 의미)

> 가변배열이 자주 등장하는 것은 아니다. 95% 이상의 경우가 모든 행마다 열 크기가 동일한 경우이다.

### 5) 2차 배열과 반복문

#### 배열의 모든 원소 스캔하기

2차 배열의 모든 원소를 반복문으로 스캔하기 위해서는 **중첩 반복문**을 사용해야 한다.

이 때 부모 반복문은 **행**에 대해 관여하고, 자식 반복문은 **열**에 대해 관여한다.




/** 
 역순배치
 [반복 회수를 구하기 위한 연산]
 1. 원소가 5개일 경우 반복 회수 : 2회
    - 5/2를 연산한다. 연산 결과를 parseInt() 명령을 통해 나머지를 버릴 수 있다 2나머지 5 -> 2
2. 원소가 6개일 경우 반복 회수 : 3회
    -6/2를 연산한다.

=> 즉 배열의 길이/2 만큼 반복 처리

[반대쪽 위치의 원소 구하기]
=> 배열의길이 i-1
 */


const data = [1, 5, 2, 4, 3];
//const data = [1, 5, 2, 4, 3, 45, 66, 8, 6, 7, 9, 54, 33, 12, 23, 34, 44, 87, 11, 14];
console.log(data);

// 반복 횟수 -> 2나누고 소수점 이하를 버린다.
const p = parseInt(data.length/2);

for (let i=0; i < p; i++) { 
    // 반대쪽 원소의 위치
    const k = data.length -i -1;
    // i번째 원소와 k번째 원소의 교환
    const tmp = data[i];
    data[i] = data[k];
    data[k] = tmp;
}

console.log(data);



/** 
 * 배열 순서대로 정렬하기
 */

const data = [ 1, 5, 2, 4, 3];
console.log(data);

// i는 배열의 원소중 마지막을 제외한 항목을 스캔한다.

for (let i=0; i<data.length-1; i++) {
    // j는 배열의 원소중 i번째 다음 원소부터 마지막 원소까지 스캔
    for (let j=i+1; j<data.length; j++) {

        // 부등호 방향 ">" : 오름차순(순차정렬)
        // 부등호 방향 "<" : 내린차순(역순정렬)
        if (data[i] > data[j]) {
            const tmp = data[i];
            data[i] = data[j];
            data[j] = tmp;

        }
    }
}

console.log(data);


/**
 * 6행 7열로 구성된 2차 배열을 준비하고,
 * 배열의 모든 칸에 1부터 순차적으로 증가하는 값을 할당하시오.
 * 단, i가 0일 때 i가 3보다 작다면 0을 대입하고 인덱스가 3인 위치부터 1씩 증가하는 값을 할당해야 합니다.
 * 또한 counter가 30보다 크다면 그 자리에는 0을 대신 할당해야 합니다.
 */


// 6행 7열의 빈 배열 만들기
var data = new Array(6);

for (let i=0; i<data.length; i++) {
    data[i] = new Array(7);
}

console.log(data);

// 1씩 증가할 값
let counter = 1;

for (let i=0; i<data.length; i++) {
    for (let j=0; j<data[i].length; j++) {
        if (i == 0 && j < 3 || counter > 30) {
            data[i][j] = 0;
        } else {
            data[i][j] = counter++;
        }
    } 
}

console.log(data);



/** 출력하기 */
for (let i=0; i<data.length; i++) {
    let str = "";
    for (let j=0; j<data[i].length; j++) {
        if (data[i][j] == 0) {
            str += "\t";
        } else {
            str += data[i][j] + "\t";
        }
    } 
    
    console.log(str);
    
}



console.group("1차배열의 탐색");

const data = [ 4, 5, 2, 1, 3 ];
for (const item of data) {
    console.log(item);
}


console.groupEnd();

console.group("2차배열의 탐색");

const myArr = [
    [1, 2, 3],
    [4, 5, 6]
];

for (const item of myArr) {
    console.log(item);

    for (const sub of item) {
        console.log(sub);
    }
}

console.groupEnd();



// true는 false로, false는 true로 저장하기
// boolean 값을 반전하기 위해서는 NOT 연산자 "!"를 사용해야 한다.
// ex) !true --> false, !false --> true
var check_list = [true, false, false, true, true];
console.log("before -->" + check_list);

for (let i=0; i<=check_list.length-1 ; i++) {
      check_list[i] = !check_list[i];
}


console.log("after --> " + check_list);



var grade = [75, 82, 91]; // 성적표 배열
var sum = 0, avg = 0; // 총점과 평균점수 변수 생성

// 또다른 반복문 패턴
for (const p of grade) {
    sum += p;
}
avg =  sum / grade.length;
avg = avg.toFixed(2);

console.log(avg);

console.log("총점: " + sum + "점, 평균점수: " + avg + "점");




/** 풀이방법(1) */
var time = [ 7, 5, 5, 5, 5, 10, 7];
var money = 0;

 for (let i=0; i<time.length; i++) {
     if (i < 4) {
         money += time[i] * 4500;
     } else {
         money += time[i] * 5200;
     }
 }

 console.log("1주일간의 전체 급여: " + money + "원");

 /** 풀이방법(2) */
var time = [ 7, 5, 5, 5, 5, 10, 7];
var money = 0;

 let x = 0;
 if (i < 4){
     x = 4500;
 } else {
    x = 5200;
 }

 money += time[i] * x;
 console.log("1주일간의 전체 급여: " + money + "원");

 /** 풀이방법(3) */
 var time = [ 7, 5, 5, 5, 5, 10, 7];
 var money = 0;
let x = (i < 4) ? 4500 : 5200;
money += time[i] * x;
console.log("1주일간의 전체 급여: " + money + "원");

/** 풀이뱅법(4) */


var time = [ 7, 5, 5, 5, 5, 10, 7];
var money = 0;
money += time[i] * ((i < 4) ? 4500 : 5200);  
console.log("1주일간의 전체 급여: " + money + "원");






// 단가 정보
var price = [38000, 20000, 17900, 17900]; 
// 수량 정보
var qty = [ 6, 4, 3, 5]; 
// 총 합계 금액
let money = 0;

for (let i=0; i<price.length; i++) {
    // 단가 * 수량의 합을 구한다.
    money += price[i] * qty[i];
}
console.log("전체 결재 금액: " + money +"원");





// 강사님 풀이
//단가 배열
var price = [38000, 20000, 17900, 17900];
// 주문 수량 배열
var qty = [ 6, 4, 3, 5];

// 단가 * 수량 중에서 가장 큼 값을 구해야 하므로 처음에 저장하는 값도 단가 * 수량으로 설정
let money = price[0] * qty[0];

// 단가 * 수량에 대한 최대값 구하기
// --> 인덱스가 동일한 요소들끼리 계산이므로
//      인덱스 번호를 알 수 없는 for-of 문은 사용할 수 없다. 
for (let i=0; i<price.length; i++) {
    // i번째에 대한 총금액을 구한다. 
    const sum =  price[i] * qty[i];
    if (money < sum) {
        money = sum;
    }
}       

console.log("가장 높은 상품금액: " + money +"원");



//단가 배열
var price = [38000, 20000, 17900, 17900];
// 주문 수량 배열
var qty = [ 6, 4, 3, 5];
// 수량을 저장할 변수 선언 --> 덧셈(합계, 카운트 등) 계산에서는 0으로 초기화
let count = 0;

for (let i=0; i<price.length; i++) {
    // i번째에 대한 총금액을 구한다.
    const sum = price[i] * qty[i];

    // 원하는 조건이 충족될 때 카운트 증가
    if (sum >= 80000) {
        count ++;
    }
}

console.log("무료배송 항목: " + count +"건");



var price = [209000, 109000, 119000, 109000, 94000];
console.log("상품가격 --> " + price);

let min = price[0];

for (var i=0; i<price.length -1; i++) {
    for (var j=i+1; j<price.length; j++) {
        if(price[i] > price[j]) {
            var tmp = price[i];
            price[i] = price[j];
            price[j] = tmp;
        }
    }    
}

console.log("낮은가격순 --> " + price);


// 낮은 가격순으로 정렬 수행
// (공식) 부모 반목문 -> i가 0부터 길이 -1보다 작은 동안
//        자식 반복문 -> j가 i+1부터 길이보다 작은 동안
//        i번째와 j번째의 크기를 비교하여 맞교환 처리 수행




var arr = [5, 3, 2, 8, 9];
console.log('before --> ' + arr);

for (var i=0; i <parseInt(arr.length/2); i++) {
    const tmp = arr[i];
    arr[i] = arr[arr.length -i -1];
    arr[arr.length -i -1] = tmp;
}
                 
console.log('after --> ' + arr);


// 역순 배치 공식
// 1) 배열길이/2 만큼만 반복
// 2) i번째 길이-i-1 번째를 맞교환





/** 학생이름 배열 */
var student = ['둘리', '도우너', '또치', '희동'];

/** 성적표 배열 */
var grade = [
    [ 78, 89, 96 ],
    [ 62, 77, 67 ],
    [ 54, 90, 80 ],
    [ 100, 99, 98],
]

// 총점과 평균점수를 저장할 변수
var sum = 0, avg = 0;


/** 총점과 평균 구하기 */
// 학생별 반복 처리
for (let i=0; i<grade.length; i++){
    // 학생별 총점은 이 위치에서 변수가 초기화 되어야 한다.
    // 합계를 위한 변수가 이미 선언되어 있으므로 중복선언을 피하기 위해서
    // 기존의 변수를 0으로 리셋만 한다.
    sum = 0;

    // 각 학생의 과목별 반복 처리
    for (let j=0; j < grade[i].length; j++) {
        sum += grade[i][j];
    }

    // 평균은 학생 한명의 총점을 한명이 응시한 과목수(=배열의 길이)로 나눈다.
    avg = sum/grade[i].length;
    // 소수점 둘째자리까지 표현하기
    avg = avg.toFixed(2);

    // student[i]가 학생 한명의 이름, grade[i]는 학생 한명의 점수
    console.log(student[i] + "총점: " + sum + "점, 평균: " + avg + "점");
}



/** 학생이름 배열 */
var student = ['둘리', '도우너', '또치', '희동'];

/** 성적표 배열 */
var grade = [
    [ 78, 89, 96 ],
    [ 62, 77, 67 ],
    [ 54, 90, 80 ],
    [ 100, 99, 98],
];

// 총점과 평균점수를 저장할 변수
var sum = 0, 
    avg = 0;

//학생별 평균점수의 총 합
var class_sum = 0;

// 반평균
var class_avg = 0;

/** 총점과 평균 구하기 */
for (let i=0; i < grade.length; i++) {
    sum = 0;
    
    for (let j = 0; grade[i].length; j++) {
        sum += grade[i][j];
    }
    avg = sum / grade[i].length;
    // toFixed()함수로 소수점을 처리한 결과는 문자열이기 떄문에 숫자 연산이
    // 불가능하므로 toFixed() 함수 적용 전에 반점수를 구해야 한다.

    class_sum += avg;

    avg = avg.toFixed(2);

    console.log(student[i] + '총점: ' + sum + '점, 평균:' + avg + '점');
    
}

class_avg = class_sum / student.length;
class_avg.toFixed(2);
console.log('반평균=' + class_avg + "점");





// "단가 - 수량"을 한 세트로 하는 정보들은 배열로 구성하면 2차 배열 형태가 된다.
const inven = [
    [500, 291], [320, 586], [100, 460], [120, 558], [92, 18], [30, 72]
];

let total_price = 0;

for (let i=0; i<inven.length; i++) {
    //console.log(inven[i]);

    const itme_price = (inven[i][0]*0.9 * inven[i][1]);
    total_price += itme_price;
}

console.log("아이템 총 판매가격: " + total_price + "G");


// -----------------------------------------------------------
// case 2
// -----------------------------------------------------------

const inven2 = [
    [500, 320, 100, 120, 92, 30],
    [291, 586, 460, 558, 18, 72]
];

let total_price2 = 0;

// 0번째 행과 1번째 행의 길이가 동일함이 보장되므로
// 0번째 행에 대한 길이를 직접 구해서 처리한다.
for (let i=0; i<inven2[0].length; i++){
    total_price2 += (inven2[0][i] * 0.9 ) * inven2[1][i];
}

console.log("아이템 총 판매가격: " + total_price2 + "G");






// 자신의 주민번호 한 글자씩 모든 숫자를 원소로 갖는 jumin을 정의
// --> 이 값은 가짜 주민번호이므로 실행결과는 유효하지 않은 주민번호라고 판별될 것이다.
ssn = [0,1,1,2,1,3,1,0,0,0,1,2,3]

/** 정의된 배열을 활용하여 유효한 주민번호인지 아닌지를 판별 */

// 기본 주민등록코드에는 각 숫자에 대응하는 가중치가 있다. 가중치는 주민등록번호의 순서에 따라 `2 3 4 5 6 7 8 9 2 3 4 5` 이다.
// -> 가중치 변수 k
let k = 2;

// 마지작 숫자는 제외하고, 기본코드의 각 12자리와 가중치를 모두 곱하여 합한다.
let sum = 0;

for (let i=0; i<ssn.length-1; i++) {
    sum += ssn[i] * k;

    // 다음번 숫자와 곱하기 위해 가중치를 1증가
    k++;

    // 가중치 값이 9보다 크면 2로 리셋
    if (k > 9){
        k = 2;
    }
}

// 합한 값을 11로 나눈 나머지 값을 구한다.
let mod = sum % 11;

// 11에서 그 나머지 값을 뺀 후, 이를 10을 나눈 나머지를 구한다.
let x = (11 - mod) % 10;

// 나머지의 1의 자리 값과 주민등록 마지막 자리 값이 맞아야 유효한 주민등록번호이다.
let y = x % 10;

if (y == ssn[ssn.length-1]) {
    console.log("유효한 주민번호");
} else {
    console.log("유효하지 않은 주민번호");
}






# JSON

- JavaScript Object Notation (자바스크립트 객체 표기법)

## #01. Object(객체)의 임시 정의

하나의 변수 안에 다른 하위 변수를 내장하는 특수한 형태의 변수.

하위 데이터에 접근하기 위해서는 점(`.`)으로 구분한다.

```
객체변수이름.하위변수1이름 = 123;
객체변수이름.하위변수2이름 = 456;
객체변수이름.하위변수n이름 = 999;
```

즉, JSON은 어떤 변수 안에 하위 변수를 내장시키기 위한 Javascript의 표기법이다.

## #02. JSON 표기법으로 객체 정의하기

### 1) 변수들의 그룹으로서의 JSON

하나의 변수에 하위 정보들이 포함되어 있는 변수들의 그룹으로 이해할 수 있다.

```javascript
const 객체이름 = { 이름1: 값1, 이름2: 값2, ..., 이름n: 값n };
```

- key 이름을 지정하고 콜론(`:`)으로 구분지은 후 값을 명시한다.
- 두 개 이상의 데이터는 콤마(`,`)로 구분한다.
- 원칙적으로 key 이름은 따옴표로 감싸는 것이 맞지만 key 이름에 띄어쓰기나 대시(`-`)가 없는 경우는 따옴표 처리를 생략해도 무관하다.

### 2) 배열을 포함하는 JSON

JSON의 값에는 지금까지 다룬 모든 형태의 데이터 타입이 지정될 수 있다.

```javascript
const 객체이름 = { 이름1: 숫자, 이름2: 문자열, ..., 이름n: [값1, 값2, 값3 ... 값n] };

console.log(객체이름.이름n[0]);
```

### 계층 구조

JSON 표기법의 장점은 복잡한 정보 구조를 계층화 하여 표현할 수 있다는 것이다.

```javascript
const json1 = { ... };
const json2 = { ... };

const json3 = {
    data1: json1,
    data2: json2
};
```

단일 형태의 JSON 구조를 별도로 참조하는 것이 아니라 직접 정의하는 패턴

```javascript
const myjson = {
    data1: {        
        ...
    },
    data2: {
        ...
    }
};
```

### 목록 구조

JSON의 value가 배열로 정의되어 있으면서, 각 배열의 원소가 또 다른 JSON 형식인 경우.

단, 이 경우 배열의 원소로 포함되는 JSON 끼리는 동일한 구조를 갖는다.

```javascript
const 객체이름 = {
    key : [ {
        key: value, key: value...
    }, {
        key: value, key: value...
    }, {
        key: value, key: value...
    }, {
        key: value, key: value...
    } ]
}
```


## #03. JSON 구조의 확장

### 1) 존재하지 않는 key를 사용하는 경우

존재하지 않는 key에 대해 출력하거나 다른 변수에 대입할 경우 `undefined`로 처리된다.

### 2) 존재하지 않는 key에 대한 대입

그 즉시 객체가 확장된다.

#### 빈 객체 확장하기

아무런 key도 정의되지 않은 빈 json 객체에 점진적으로 내용을 덧붙여 나갈 수 있다.




// 예제를 위한 임의의 JSON 정의
const student = {
    stuno: 10101,
    grade: 1,
    nmae: "학생1",
    phoneno: "010-1231-2342"
};

// JSON이나 멤버변수를 갖는 객체에 대한 반복문
// --> 변수로 선언한 key가 순차적으로 저장된다.

for (let k in student){
    console.log("%s : %s", k, student[k]);
}


/** 
## 문제1.

다음은 10명의 학생들에 대한 혈액형 데이터이다.

```
['A', 'A', 'A', 'O', 'B', 'B', 'O', 'AB', 'AB', 'O']
```

아래와 같은 JSON을 정의하고, 각 혈액형별 학생수를 아래의 json의 각 key에 대한 value에 저장하시오.
(혈액형별 학생 수를 for문을 활용하여 산출해야 합니다.)

```js
const result = {"A" : 0, "B" : 0, "AB" : 0, "O" : 0};
```
*/

const blood_data = ['A', 'A', 'A', 'O', 'B', 'B', 'O', 'AB', 'AB', 'O'];
const result = {"A" : 0, "B" : 0, "AB" : 0, "O" : 0};

for (const b of blood_data){
  console.log(b);
  result[b]++;
  
}
console.log(result);



// 강사님 풀이 

const exam = {
    "철수": [89, 82, 79, 91],
    "민영": [91, 95, 94, 89],
    "남철": [65, 57, 71, 64],
    "혜진": [82, 76, 81, 83]
}

// JSON의 key에 대한 반복 처리
for (const key in exam) {
    //학생별 총점을 위한 변수 초기화
    //console.log(key);
    let sum = 0;

    // exam[key]는 학생 한명의 점수 배열
    // 이 배열의 원소를 스캔하는 반복문을 사용하여 총점 구하기
    for (const p of exam[key]) {
        sum += p;
    }
    // 총점을 학생 개개인의 과목수로 나누어 평균 구하기
    let avg = sum / exam[key].length;

    
    console.log("%s의 총점은 %d점 이고 평균은 %d점 입니다.", key, sum, avg);
}





const exam = {
    "철수": [89, 82, 79, 91],
    "민영": [91, 95, 94, 89],
    "남철": [65, 57, 71, 64],
    "혜진": [82, 76, 81, 83]
}

// 전체 학생에 대한 총점이므로 반복문의 바깥에서 변수 초기화
let sum = 0;

// JSON은 길이를 알 수 없기 때문에 JSON의 원소 하나를 반복문으로 스캔할 때마다
// count 변수를 1씩 증가하여 전체 학생 수를 알아내야 한다.

let student_count = 0 ;

for (const key in exam) {
    sum += exam[key][2];

    // 몇 번째 학생인지 카운트 
    student_count ++;
}

// 학생별 수학 총점 / 학생수 
let avg = sum / student_count;

console.log("모든 학생의 수학 총점은 %d점이고 평균은 %d점 입니다", sum, avg);




const covid19 = [
    {date: '0125', active: 426}, 
    {date: '0126', active: 343}, 
    {date: '0127', active: 547}, 
    {date: '0128', active: 490}, 
    {date: '0129', active: 460}, 
    {date: '0130', active: 443}, 
    {date: '0131', active: 338}, 
    {date: '0201', active: 299}
];

// 전체 확진자 수를 위한 합계 변수
let sum = 0;

for (const j of covid19){
    sum += j.active;
}

console.log("누적 확진자 수: %d", sum);
console.log("평균 확진자 수 : %d", sum / covid19.length);




const covid19 = [
    {date: '0125', active: 426}, 
    {date: '0126', active: 343}, 
    {date: '0127', active: 547}, 
    {date: '0128', active: 490}, 
    {date: '0129', active: 460}, 
    {date: '0130', active: 443}, 
    {date: '0131', active: 338}, 
    {date: '0201', active: 299}
];

let max_active = covid19[0].active;
let max_date = covid19[0].date;

for (const j of covid19) {
    if(max_active < j.active){
        max_active = j.active;
        max_date = j.date;
    }
}

console.log("확진자가 가장 많이 나타난 날: %s", max_date);




# 함수

하나의 키워드에 프로그램 로직을 함축한 형태.

명령어를 만드는 과정으로 이해할 수 있다.

이렇게 만들어진 명령어는 **여러 번 재사용이 가능**하다.

## #01. 수학적 접근

일반적인 수학의 함수는 하나의 수식을 대변하는 특정 키워드를 의미한다.

아래의 함수가 있을 때 f라는 키워드로 아래와 같이 x+1이라는 수식을 **재사용**할 수 있으며 이는 아래와 같이 조건값에 따라 각각 다른 결과를 반환하게 된다.

> $f(x) = x + 1$

즉, 아래와 같이 수식이 재활용 된다.

> $f(10) = 10 + 1 = 11$

## #02. 자바스크립트에서의 함수 개요

### 1) 함수 정의하기

**function** 키워드를 명시하고 함수의 이름을 지정한 후 괄호`()`를 명시한다. 

그 뒤에 구문을 그룹화 하기 위한 블록 `{}`을 갖는다.

```javascript
function 함수이름() {
    ... 명령어 ...
}
```

### 2) 함수의 호출

함수는 **정의하는 것 만으로는 아무런 동작을 하지 않는다.**

반드시 **정의된 함수를 실행**시키는 명령을 내려야 하는데 이를 **함수를 호출**한다고 한다.

```javascript
함수이름();
```

### 3) 함수 이름 규칙

변수와 동일하게 영어, 숫자, 언더바(`_`)의 조합으로 구성할 수 있으며, 대부분 `동사+명사`의 형태로 구성된다.

첫 글자는 소문자로 시작하며, 카멜표기법을 사용하는 것이 관례이다.


## #03. 함수가 실행되는데 필요한 조건값

필요에 따라 함수가 실행되는데 필요한 조건값을 정의할 수 있는데, 이를 **파라미터**라고 한다.

### 1) 수학에서의 의미

> $f(x) = x + 1$

함수 `f(x)`가 자신이 수행되는데 필요한 조건값 **x**를 갖는다. 수학에서는 이를 **매개변수 혹은 파라미터**라고 부른다.

### 2) 프로그램에서의 의미

#### 파라미터 정의 하기

프로그램의 함수도 자신이 실행하는데 필요한 조건값을 함수 정의 과정에서 괄호`()`안에 명시할 수 있으며 이를 파라미터라고 부른다.

```javascript
function 함수이름(파라미터) {
   ... 파라미터를 활용한 프로그램 구문 ...
}
```

#### 파라미터를 전달하는 함수 호출

파라미터가 정의된 함수를 호출할 경우 괄호`()`안에 조건에 맞는 값을 전달해야 한다.


```javascript
함수이름(값);
```

### 3) 다중 파라미터

필요한 조건 값이 여러 개인 경우 콤마(`,`)로 구분하여 나열할 수 있다.

정의된 파라미터들은 원칙적으로 함수 호출시 해당 값들을 전달해야 한다.

#### 다중 파라미터 정의 하기

프로그램의 함수도 자신이 실행하는데 필요한 조건값을 함수 정의 과정에서 괄호`()`안에 명시할 수 있으며 콤마로 구분하여 여러 개를 정의할 수 있다.

```javascript
function 함수이름(파라미터1, 파라미터2, ... 파라미터n) {
   ... 파라미터를 활용한 프로그램 구문 ...
}
```

#### 다중 파라미터를 갖는 함수의 호출

파라미터가 여러개 인 경우 함수를 호출할 때 정의되어 있는 순서대로 값을 전달해야 한다.

```jsx
함수이름(값1, 값2, ... 값n);
```

### 4) 함수 호출시 파라미터 생략하기

파라미터를 요구하는 함수라 하더라도 호출시에 필요 없는 값은 마지막 파라미터부터 순차적으로 생략 가능함.

값이 전달되지 않은 파라미터는 **undefined**로 식별된다.

### 5) 파라미터의 기본값 정의

함수 호출시 값이 전달되지 않는 경우를 대비하여 파라미터에 기본값을 정의할 수 있다.

```javascript
function 함수이름(파라미터1=기본값1, 파라미터1=기본값2, ..., 파라미터n=기본값n) {
    ...
}
```

## #03. 리턴

**함수가 자신이 만들어낸 결과값을 자신을 호출한 위치로 되돌려 주는 것.**

### 1) 수학에서의 리턴

수학에서의 함수도 자신이 호출된 위치로 결과값을 되돌려 준다.

> $f(x) = x + 1$
$y = f(5)$ ← 이 자리에 f(5)의 결과값이 반환된다.
$y = 5 + 1$
$y = 6$

### 2) JS에서의 리턴

#### 결과값을 리턴하는 함수 정의하기

함수를 구성하는 블록`{}` 안에서 **return** 키워드를 사용하여 값을 전달한다.

```javascript
function 함수이름(파라미터1, 파라미터2, ... 파라미터n) {
    ... 파라미터를 활용한 프로그램 구문 ...
    return 돌려줄_값;
}
```

#### 리턴값을 다른 변수에 할당

리턴값을 갖는 함수는 그 결과를 다른 변수에 대입할 수 있다.

```javascript
const 변수 = 함수이름(파라미터1, 파라미터2, ... 파라미터n);
```

#### 리턴값을 활용한 새로운 수식 구성

함수의 리턴값을 새로운 수식에 포함시킬 수 있다.

```jsx
const 변수 = 100 + 함수이름(파라미터1, 파라미터2, ... 파라미터n);
```

#### 리턴값을 조건식으로 활용하기

함수의 리턴값과 비교식을 구성하여 조건문으로 사용할 수 있다.

```jsx
if (함수이름(파라미터1, 파라미터2, ... 파라미터n) > 0) {
   ...
}
```

#### 논리값을 리턴하는 함수의 조건식 활용

함수의 리턴값이 논리값(`true` / `false`)이라면 그 자체를 조건으로 사용할 수 있다.

```jsx
if (함수이름(파라미터1, 파라미터2, ... 파라미터n)) {
   // 함수의 리턴값이 true인 경우 실행됨
}

if (!함수이름(파라미터1, 파라미터2, ... 파라미터n)) {
   // 함수의 리턴값이 false인 경우 실행됨
}
```

#### 리턴값을 활용한 반복문

함수의 리턴값을 활용하여 반복문의 조건식을 구성할 수 도 있다.

```jsx
for (let i = 0; i<함수이름(파라미터1, 파라미터2, ... 파라미터n); i++) {
   ...
}
```

#### 함수의 실행 중단

함수가 실행되는 도중 **return** 키워드를 만나면 그 즉시 실행을 종료한다.


## #04. 익명함수

### 1) 함수를 변수에 대입하기

자바스크립트는 **함수 자체가 객체**이기 때문에 다른 변수에 참조시켜 사용할 수 있다.

```javascript
function 함수이름(...) {
   ...
}

const 변수 = 함수이름;
```

> 여기서는 객체를 특수한 기능을 갖는 변수의 한 종류로 이해합시다.   
1) 변수의 종류(데이터 타입)   
    - number, string, boolean, object(객체)...   
    ==> 객체는 변수의 한 종류~   
2) JSON   
   어떤 변수가 그 안에 하위 변수를 내장하고 있는 특수한 형태   
   ==> 1, 2 객체가 무엇인지 아직은 명확하진 않지만...      
   일단 변수의 한 종류인가 보다 ~~~      
   
### 2) 익명함수

다른 변수에 참조시킬 목적으로 함수를 정의할 때 부터 이름 없이 정의하는 형태

전체적인 정의 형태가 **대입문**이므로 블록을 구성하는 중괄호`{}`뒤에 세미콜론(`;`)이 위치해야 한다.

```javascript
const 변수 = function(...) {
   ...
};
```


## #05. 화살표 함수 (arrow function)

ES6 버전부터 새롭게 추가된 구문 형식으로 기존의 익명함수 문법을 간단하게 축약하여 사용할 수 있다.( 람다식, arrow function)

### 1) 익명함수와의 비교

#### 익명함수 형태로 정의한 함수.

익명함수는 변수에 함수를 대입하는 형태로 정의한다.

```jsx
const 변수 = function(파라미터1, 파라미터2, ... 파라미터n) {
    ... 처리로직 ...
};
```

#### 화살표 함수 형태로 정의한 동일한 함수

**function** 키워드가 삭제되고 파라미터를 전달하기 위한 소괄호`()`와 블록을 구성하기 위한 중괄호`{}` 사이에 `=>` 기호가 추가된다.

```jsx
const 변수 = (파라미터1, 파라미터2, ... 파라미터n) => {
    ... 처리로직 ...
};
```

### 2) 화살표 함수 살펴보기

#### 파라미터가 하나만 존재하는 경우

파라미터를 감싸는 소괄호 `()` 를 생략할 수 있다. 파라미터가 없거나 두 개 이상인 경우는 소괄호를 `()` 생략할 수 없다.

```jsx
const 변수 = 파라미터 => {
    ... 처리로직 ...
};
```

#### 처리 로직이 한 줄만 포함되는 경우

리턴을 위한 구문 한 줄만 포함하는 익명함수를 가정해 보자.

```jsx
const 변수 = function(파라미터1, 파라미터2, ... 파라미터n) {
    return 리턴값;
};
```

위와 같은 형태를 화살표 함수로 변경하고자 할 때, 블록을 위한 {}를 생략하고 return 키워드도 생략할 수 있다.

```jsx
const 변수 = (파라미터1, 파라미터2, ... 파라미터n) => 리턴값;
```



## #06. 콜백함수(중요)

함수 == 객체 -> 변수의 종류   
변수는 일반 지역변수, 전역변수, 상수   
파라미터, 리턴값으로 사용 가능함.    


파라미터로 전달되기 위해 사용되는 함수.

어떤 함수 A가 동작하는 과정 중에서 일부에 대한 처리가 상황에 따라 다르게 구성되어야 할 경우, 그 부분을 함수 형태로 묶어 파라미터로 받도록 할 수 있다.


## #07. 재귀함수

함수가 처리로직 내부에서 자기 자신을 호출하는 형태.

재귀호출은 마지막에 종료 조건을 명시하지 않는다면 무한루프에 빠지게 된다. 그러므로 재귀호출을 구현할 때 가장 먼저 처리해야 할 것은 종료조건을 명시하는 것이다.

```javascript
function 함수이름(파라미터1, 파라미터2, ... 파라미터n) {
    if (종료조건) {
        return 값;
    } else {
        // 자기 스스로를 호출한다.
        함수이름(파라미터1, 파라미터2, ... 파라미터n);
    }
}
```

### 팩토리얼 구하기


팩토리얼의 수식을 분석해 본다면 다음과 같이 정의할 수 있다.

> $f(x) = x * f(x-1)    (단, x가 1 이하인 경우 1)$


5! = 5 * 4 * 3 * 2 * 1
f(x) = x * f(x-1)

f(x) = x * f(x-1), 단 f(1) = 1

f(5) =  5 * f(4)
              4 * f(3)
                3 * f(2)
                    2 * 1 

function fact(x) {
    if ( x == 1) {
        return 1;
    } else {
        return x * fact(x-1);
    }
}



/** 간단한 화살표 함수 기본형 */

// const foo = function(x) {

const foo = (x) => {
    for (let i=-0; i<x; i++){
        console.log("Hello World");
    }
};

foo(7);


/** 파라미터가 하나만 존재할 경우 소괄호 생략 */
// 파타리터가 없거나, 두 개 이상이면 괄호 생략 불가.

const bar = x => {
    for (let i=0; i<x; i++){
        console.log("Hello World");
    }
};

bar(3);

/** 처리 로직이 한 줄만 존재하는 경우 */
// 파라미터 x, y를 받아서 x+y를 리턴하는 arrowReturn 이라는 이름의 함수
// const hello = (x, y) => {
//     return x*y;
// };

const hello = (x, y) => x*y;
console.log(hello(100, 400));


재귀함수-구구단
function gugu(level, depth=1) {
    if (depth > 9) {
        return;
    } else {
        console.log(level + " x " + depth + " = " + (level*depth));
        gugu(level, depth+1);
    }
}

gugu(5);




재귀함수-피보나치수열
/**
 * 피보나치수열에서 10번쨰 항목이 무엇인지 출력하시오.
 * 
 * 0 1 1 2 3 5 8 13 21 34 55 . . . 
    f(0) = 0
    f(1) = 1
    f(2) = f(1) + f(0) = 1
    f(3) = f(2) + f(1) = 2
    f(4) = f(3) + f(2) = 5
    f(5) = f(4) + f(3) = 7
  
    ...

    f(n) =  f (n-1) + f(n-2)
 */

    function fibonacci(n) {
        if (n < 2) {
            return n;
        } else {
            return fibonacci(n-2) + fibonacci(n-1);
        }
    }

    console.log(fibonacci(10));



// ## 문제1.

// 아래의 형태로 출력하는 함수를 구현하시오.

// ```js
// // max는 출력해야 할 최대 라인 수
// function printStar(max) {
//     ... 구현하세요 ...
// }

// printStar(5)
// ```

// #### 출력결과

// ```
// *
// **
// ***
// ****
// *****
// ```



function printStar(max) {
    
    // 반복문이 중첩되었을 때 바깥의 반복문은 행을 의미
    // max는 행의 수를 의미하므로 바깥 반복문의 조건식에서 활용해야 한다.
    for (let i=0; i<max; i++){
        let star = "";

        for(let j=0; j<i+1; j++){
            star += "*";
        }
        console.log(star);
    }
}


printStar(5);




// ## 문제2.

// 1번 문제를 응용하여 같은 파라미터를 받았을 때 별을 역으로 출력하는 `printRevStar(max)` 을 구현하시오.


// #### 출력결과

// ```
// *****
// ****
// ***
// **
// *
// ```



function printRevStar(max) {
    
    for (let i=max; i>0; i--){
        var star = "";
        for (let j=1; j<=i; j++){
            star += "*";
        }
            console.log(star);
    }
}

printRevStar(5);




// ## 문제3

// 369게임은 숫자를 순서대로 말하면서 3,6,9가 포함된 횟수만큼 박수를 치는 게임이다.

// 1부터 파라미터로 전달된 숫자까지 반복하면서 박수를 칠 조건이 충족되면 3,6,9 게임 규칙에 따라 박수를 의미하는 "짝"을 출력하고 그렇지 않은 경우에는 숫자를 출력하고, 박수를 총 몇번 쳤는지를 리턴하는 함수 `myGame(n)`을 작성하시오.

// 힌트: 문자열은 그 자체가 배열로 인식됩니다.

// ex)
// ```js
// const str = "Hello";
// console.log(str[0]); // --> H
// console.log(str[1]); // --> e
// console.log(str[2]); // --> l
// ```

// #### 출력예시

// myGame(35)를 호출한 경우

// ```
// 1
// 2
// 짝(3) --> 1번
// 4
// 5
// 짝(6) --> 1번
// 7
// 8
// 짝(9) --> 1번
// 10
// 11
// 12
// 짝(13) --> 1번
// 14
// 15
// ...
// 짝(29) --> 1번
// 짝(30) --> 1번
// 짝(31) --> 1번
// 짝(32) --> 1번
// 짝짝(33) --> 2번
// 짝(34) --> 1번
// 짝(35) --> 1번

// 박수를 총 OO번 쳤습니다.
// ...

// ```






function myGame(n) {

    let count = 0;
    // 박수를 총 몇 번 쳤는지 

    for (let i=0; i<=n; i++){
        //console.log(i);

        // 현재 숫자(i)를 문자열로 변환함. 33 --> "33";
        // --> 문자열은 그 자체가 배열이므로 각 자리의 숫자를 의미하는 글자를 원소로 갖는 배열이 된다고 볼 수 있다. 

        const str = i + "";
       // console.group(i);

        // 출력할 문자열(숫자인지 박수소리인지 ...)
        let say = "";
        
        // 이번 턴에 박수를 몇 번 치는 지 카운트하는 변수
        let clap = 0;
        for (let j of str) {
            //console.log(j);

            if ( j == "3" || j == "6" || j == "9"){
                say += "짝";
                clap++;
            }
        }

        //console.groupEnd();

        if ( clap == 0) {
            console.log(i);
        } else {
            console.log("%s  (%d) --> %d번", say, i , clap);
            count += clap;
        }
    }

    console.log();
    console.log("박수를 총 %d번 쳤습니다.", count);

}





myGame(35);






// ## 문제4

// 문제1번을 재귀함수 기법으로 다시 구현해 보세요.

// ```js
// // max는 최대 행 수, current는 현재 출력중인 행의 위치
// function printStar(max, current=1) {
//     ... 구현하세요 ...
// }

// printStar(5);
// ```


// ```js
// // max는 출력해야 할 최대 라인 수
// function printStar(max) {
//     ... 구현하세요 ...
// }

// printStar(5)
// ```

// #### 출력결과

// ```
// *
// **
// ***
// ****
// *****
// ```


// 문제1번을 화살표 함수가 적용된 재귀함수 기법으로 다시 구현해 보세요.




function printStar(max, current=1){
    
    // max는 최대 행의 수, current는 현재 행의 수를 의미하므로,
    // 현재 행의 수가 최대 행보다 크다면 처리 중단을 위해  return 함
    if (current > max){
        return;
    } else {
        /** 한 줄을 출력하기 위한 코드 구성 */
        let star = "";

        for (let j=0; j<current; j++){
            star += "*";
        }
        console.log(star);
        printStar(max, current+1);
    }
}

printStar(5);




// ## 문제5 

//문제2번을 재귀함수 기법으로 다시 구현해 보세요.

// 강사님 풀이

function printRevStar(max, current=1){
    
    // max는 최대 행의 수, current는 현재 행의 수를 의미하므로,
    // 현재 행의 수가 최대 행보다 크다면 처리 중단을 위해  return 함
    if (current > max){
        return;
    } else {
        /** 한 줄을 출력하기 위한 코드 구성 */
        let star = "";

        for (let j=0; j<max-current+1; j++){
            star += "*";
        }
        console.log(star);
        printRevStar(max, current+1);
    }
}

printRevStar(5);



# 클래스와 객체
연관 있는 데이터들을 한군데 모아 놓는 컨테이너 같은 역할을 한다.

```javascript
// 클래스 선언
class person {
    name; // 프로퍼티(혹은 속성(filed))
    age; // 프로퍼티(혹은 속성(filed))
    speak(); // 메소드
}

// 객체 생성
// 객체를 생성할 때는 클래스앞에 new라는 키워드를 사용한다.
const mike = new Person('mike', 20);
console.log(mike.name);
console.log(mike.age);
```
자바스크립트에서 클래스의 ES6에서 소개되었다.
그전에는 클래스를 정의하지 않고 객체를 정의해서 사용하는 방법이 있었고
객체를 만들때 함수를 이용해서 템플릿(클래스 같은 역할)을 만드는 방법이 있었다.

### 클래스
- template, 즉 틀 같은 역할을 한다.
- 한번만 선언한다.
- 클래스 안에는 데이터가 없다.
- 메모리에 올라가지 않는다.

### 객체
- instanc of a class, 클래스의 인스턴스이다.
- 1개의 클래스로 여러개의 객체를 만들수 있다.
- 객체 안에는 데이터가 있다.
- 메모리에 올라간다.

> 클래스는 달고나 틀
> 객체는 클래스(달고나 틀)로 찍어낸 달고나
> 즉 클래스를 정의해서 다양한 객체들을 만든다.

## 1. 생성자 (Constructor)
생성자는 객체를 생성할 때 인자를 프로퍼티에 전달하여 생성한다.

즉, 객체를 만들때 필요한 데이터를 전달하여 생성한다.
```javascript
class Person {
  // constructor(생성자)
  constructor(name, age) { // 인자를 받아 할당한다.
    // fields
    this.name = name; // this는 객체(변수명)를 지칭한다.
    this.age = age; // this.name, this.age는 클래스의 필드(프로퍼티)이다.
  }

  // methods
  speak() {
    console.log(`${this.name}: hello!`);
  }
}
```
인자를 전달할 필요가 없이 프로퍼티를 선언하고 할당 할 수 있다.
```javascript
class Person {
    name = 'mike';
	age = 21;
}
```

## 2. Getter & Setter
getter는 객체의 특정 프로퍼티 값을 가져오도록 하기 위한 메소드이다.

setter는 객체의 특정 프로퍼티 값을 설정하기 위한 메소드이다.

둘 다 프로퍼티 처럼 사용한다.


### getter
```javascript
get probName() { // 인자를 받지 않는다.
  return this._probName;
}
```
동적으로 계산이 필요한 프로퍼티 값을 가져와야 할 때 사용한다.

`obj.propName` 을 사용해 프로퍼티를 읽으려고 할 때 실행이 된다.

`obj.propName` 을 사용할 때 `get propName() {}` 이 호출되어 계산이 된 이후에 리턴받은값이 `obj.propName` 의 값이 되어진다.

#### getter의 기능

1. 계산 미루기
etter가 호출되기 전까진 계산을 하지 않고 대기한다. getter의 값계산은 실제 값이 필요할 때 이루어 지게 된다.

1. 캐싱처리
getter는 프로퍼티 값을 나중에 접근하기 위해 값을 캐싱한다. 값은 getter가 호출될 때 계산되며, 캐싱하게 된다. (이후의 호출은 다시 계산하지 않고 이 캐시값을 반환한다.)


### setter
```javascript 
set probName(value) { // 인자를 받아서 할당한다.
    this._probName = value < 0 ? 0 : value; 
  }
```
프로터티 값이 변경되어 질 때마다 함수를 실행하는데 사용이 된다.

`obj.propName = value` 으로 프로퍼티에 값을 할당하려 할 때 실행됩니다.

`obj.propName = value` 을 사용할때 `set propName() {}` 이 호출되어 `obj.propName` 에 값이 저장된다.

setter는 주로 잘못된 값을 할당 할 때 예외처리를 하기 위해 사용한다.

예를들어 Person클래스에 age프로퍼티가 있는데 age에 음수값을 할당하면 말이 안되기 때문에 음수를 넣으면 에러를 던저주거나 0을 저장한다.


예제
```javascript
class User {
  constructor(firstName, lastNamem, age) {
    this.firstName = firstNamem;
    this.lastName = lastNamem;
    this.age = age;
  }

  get age() {
    return this._age;
  }

  set age(value) {
    // 잘못된 값 할당 적극적으로 막기 (에러 던저주기)
    // if (value < 0) {
    //   throw Error(`age can not be negative`);
    // }
    
    // 잘못된 값 할당 젠틀하게 막기 (0으로 저장하기)
    this._age = value < 0 ? 0 : value; 
  }
}
```
이 때 getter와 setter 안에서 사용되는 프로퍼티 이름앞에 관습적으로 언더바를 작성해준다.

`this.age` 를 호출하면 `get age() {}` 가 호출되어 지는데 안에서 또 this.age 를 사용하면 다시 `get age() {}` 가 호출되어 무한루프에 빠지기 때문이다. 이 때 `get age() {}` 안에서는 `this._age` 같은 형태로 작성하면 무한루프를 방지할 수 있다.

마찬가지로 `this.age = value` 와 같이 값을 할당할 때 `set age() {}` 가 호출되어 지는데 안에서 또 다시 `this.age = value` 와 같이 사용하면 또다시 `set age() {}` 가 호출되어 무한루프에 빠지기 때문이다. 이 때 `set age() {}` 안에서는 `this._age = value` 같은 형태로 작성하면 무한루프를 방지할 수 있다.


## 3. Public & Private (공개 프로퍼티와 비공개 프로퍼티)
최신에 도입되었기 때문에 아직 브라우저에 지원되지 않는 경우가 있다.


### Public Property (공개 프로퍼티)
클래스에서 일반적인 방식으로 프로퍼티를 선언하고 할당하면 Public Property(공개 프로퍼티)이다

퍼블릭 프로퍼티는 외부에서 프로퍼티에 접근하여 값을 사용하거나 수정이 가능하다.


### Private Property (비공개 프로퍼티)
클래스에서 프로퍼티 앞에 `#` 키워드를 작성하여 선언하면 Private Property (비공개 프로퍼티)가 된다.

프라이빗 프로퍼티는 오직 클래스 안에서만 사용, 변경이 가능하다. 외부에서는 접근이 불가능하다.

```javascript
class Experiment {
  publicField = 2; // 퍼블릭 프로퍼티, 위부에서 프로퍼티에 접근하여 값을 사용하거나 수정이가능하다.
  #privateField = 0; // 프라이빗 프로퍼티, 오직 클래스안에서만 사용, 변경이 가능하다. 외부에서 사용불가.
}
const experiment = new Experiment();
console.log(experiment.publicField);
console.log(experiment.privateField); // undefined
```

## 4. Static property and methods
클래스를 선언할때 프로퍼티와 메소드 앞에 `static` 키워드를 작성하여 선언한다.

static property와 static method 는 객체로 접근하여 사용할 수 없다. ( `obj.propery` , `obj.method` )

클래스(클래스명)로만 접근하여 사용할 수 있다. ( Class.propery , Class.method )

어떤 객체든 상관없이 공통된 모든 객체에 같은 프로퍼티, 메서드가 필요할 때 사용하면 메모리를 줄일수 있는 이점이 있다.


예제
```javascript
class Article {
  static publisher = 'alice'; // Static property
  constructor(articleNumber) {
    this.articleNumber = articleNumber; // 일반적인 property
  }

  static printPublisher() { // Static methods
    console.log(Article.publisher);
  }
}

const article1 = new Article(1);
// bad
console.log(article1.publisher); // undefined
article1.printPublisher(); // 에러

// good
console.log(Article.publisher);
Article.printPublisher();
```

## 5. 클래스 상속 (Inheritance)

### 상속
클래스에서 다른 클래스로 상속하면서 클래스의 기능을 확장해 나갈수 있다.

상속받을 클래스를 선언할 때 `extend 부모클래스` 키워들 사용하여 선언한다.
```javascript
class 자식클래스 extends 부모클래스 {}
```
예제
```javascript
class Shape {
  constructor(width, height, color) {
    this.width = width;
    this.height = height;
    this.color = color;
  }

  draw() {
    console.log(`drawing ${this.color} color of`);
  }

  getArea() {
    return this.width * this.height;
  }
}
```
Shape 라는 부모 클래스를 선언한다.

```javascript
class Rectangle extends Shape {} // Shape의 모든 정의들이 Rectangle클래스에 포함이 된다.
class Triangle extends Shape {
  getArea() {
    // 메서드 오버라이딩 - Shape에 정의되었던 메서드를 덮어씌워서 재정의한다.. 프로퍼티도 오버라이딩이 가능하다.
    return (this.width * this.height) / 2;
  }

  draw() {
    super.draw(); // super는 부모클래스, 즉 Shape클래스를 지칭한다.
    console.log(`🔺`);
  }
}

const rectangle = new Rectangle(20, 20, 'red');
rectangle.draw();
console.log(rectangle.getArea());

const triangle = new Triangle(20, 20, 'blue');
triangle.draw();
console.log(triangle.getArea());
```
Rectangle클래스와 , Triangle클래스가 Shape클래스를 상속받는다.

상속받을때 프로퍼티와 메소드는 오버라이딩이 가능하다.

`spuer.메서드`, `spuer.프로퍼티` 로 부모클래스의 메서드와 프로퍼티에 접근이 가능하다.

### 오버라이딩

자식클래스가 부모클래스를 상속받으면서 선언될 때

부모클래스의 프로퍼티와 메서드를 다시 새롭게 정의하여 덮어 씌운다.

## 6. Class checking: instanceOf
```javascript
객체 instancof 클래스
```
객체가 클래스의 속해있는지 여부를 확인하는 용도이다.

결과는 bool이다.

```javascript
console.log(rectangle instanceof Rectangle); // true
console.log(triangle instanceof Rectangle); // false
console.log(triangle instanceof Triangle); // true
console.log(triangle instanceof Shape); // true
console.log(triangle instanceof Object); // true, 
// 모든 객체는 자바스크립트의 Object클래스를 상속한다. 따라서 Object에 정의되어있는 메서드를 오버라이딩 할수도 있다.
```

## 참고
MDN, 자바스크립트에 내장된 객체(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference)

자바스크립트 내부에 포함되어있는 객체들이 어떤게 있는지 카테고리화 되어 있어 참고하기 좋다.


> 출처 : https://velog.io/@younoah/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B0%9D%EC%B2%B4-%EC%B4%9D%EC%A0%95%EB%A6%AC

   
      


### Class 초기값 설정해주기
Constructor(생성자)를 이용하면 class 객체의 초기 값을 설정해 줄 수 있다.
class 내부에서 Constructor는 한 개만 존재할 수 있으며, 2번 이상 사용 시 Syntax Error가 발생할 수 있다.
Constructor를 이용하여 Person 클래스에 초기 값을 설정해보도록 하자. 

```javascript
class Person { 
    constructor (name,age, city) { 
        console.log('construtor'); 
        this.name = name; 
        this.age = age; 
        this.city = city; 
    } 
} 
let kim = new Person('kim','24','seoul'); 
console.log(kim);
```
![ALT](./image/01.png)   
이처럼 Constructor는 새로운 클래스를 생성할 때 가장 처음 실행되면서 초기값을 설정해준다. 

### Class  메서드 사용하기
class에서 설정한 초기값을 접근해 특정 기능을 하는 메서드를 만드는 것도 가능하다.   
간단한 메서드를 하나 만들어보자.   
class안에 function 형식으로 만들어준 뒤 해당 메서드를 호출하기만 하면 된다.   
너무 당연하지만 내년에 해당 사람이 한 살 더 먹는다는 메서드를 class안에 정의한 뒤 호출해봤다.
```javascript
class Person { 
    constructor (name,age, city) { 
        this.name = name; 
        this.age = age; 
        this.city = city; 
    } 
        //메서드생성 
    nextYearAge() { 
        return Number(this.age) + 1; 
    } 
}

```
![ALT](./image/02.png)

class는 javascript 상 객체의 형태이므로 생성된 class 객체에
class 밖에서 새로운 메서드를 넣는 것도 가능하다.
다음 예시를 보자.

```javascript
class Person { 
    constructor (name,age, city) { 
        this.name = name; 
        this.age = age; 
        this.city = city; 
        } 
        //메서드생성 
        nextYearAge() { 
            return Number(this.age) + 1; 
        } 
    } 
    let kim = new Person('kim','24','seoul');

    kim.eat = function () { 
        return 'apple' 
    } 
    
    console.log(kim.nextYearAge()); 
    console.log(kim.eat());
```
![ALT](./image/03.png)

class밖에서 추가한 eat이라는 메서드도 정확히 작동한다.   
하지만, 이렇게 밖에서 추가한 class는 추후 새로운 new Person class로 새로운 객체를 만들었을 때는
호출하여 사용할 수 없다.

```javascript
class Person { 
    constructor (name,age, city) { 
        this.name = name; 
        this.age = age; 
        this.city = city; 
    } 
    //메서드생성 
    nextYearAge() { 
        return Number(this.age) + 1; 
    } 
} 
let kim = new Person('kim','24','seoul'); 

kim.eat = function () { 
    return 'apple' 
} 

console.log('김씨 내년에는 몇살인가요 ?' + kim.nextYearAge()); 
console.log('김씨가 먹은건? ' + kim.eat()); 

let park = new Person('park', '31', 'busan'); 

console.log('박씨 내년에는 몇살인가요?' + park.nextYearAge()); 
console.log('박씨가 먹은건?' + park.eat())

```
![ALT](./image/04.png)   
park class에서 eat 호출 시 실행되지 않음

### 상속(extends)
class에서 상속 개념을 이용할 수 있습니다.   
css를 이용한 분들이라면 하나의 속성이 하위 속성에도 같이 적용되는 것처럼
class에서도 상속을 이용하면 기존의 class의 값을 모두 접근하여 사용할 수 있다.   
상속은 extends를 써서 이용할 수 있다.   
다음 예제를 통해서 introducePerson클래스에서 Person을 상속받았기 때문에 this.city와 this.name을 모두 사용할 수 있는 것을 확인할 수 있다.

```javascript
class Person { 
    constructor (name,age, city) { 
        this.name = name; 
        this.age = age; 
        this.city = city; 
    } 
    //메서드생성 
    nextYearAge() { 
        return Number(this.age) + 1; 
    } 
} 

class introducePerson extends Person {
    introduce () { 
        return `저는 ${this.city}에 사는 ${this.name} 입니다.` 
    } 
} 

let kim = new introducePerson('kim','24','seoul'); 

console.log(kim.introduce())
```
![ALT](./image/05.png)


### super 사용하기
 

introducePerson 하위 클래스에서 기존 class의 값을 가져다 쓰는 건 좋았지만, 추가적으로 introducePerson이라는 하위 클래스에서만 사용하고 싶은 값이 있을 수도 있다.

 이때 이용하는 것은 super라는 키워드이며 이는 객체의 부모가 가지고 있는 메서드를 호출할 수 있다.

 자식 쪽의 추가적으로 사용할  초기값이 필요할 경우 constructor에 super로 부모 초기값을 세팅한 뒤 자식 class에서만 사용할 초기값을 따로 지정하는 것도 가능하며 super 기능을 이용해서 자식 class에서 부모 메서드를 호출할 수도 있다.

```javascript
class Person { 
    constructor (name,age, city) { 
        this.name = name; 
        this.age = age; 
        this.city = city; 
    } 
    //메서드생성 
    nextYearAge() { 
        return Number(this.age) + 1; 
    } 
} 

class introducePerson extends Person { 
    constructor(name, age, city, futureHope) { 
        super(name, age, city); 
        this.futureHope = futureHope
        } 
        introduce () { 
            return `저는 ${this.city}에 사는 ${this.name} 입니다. 
            내년엔 ${super.nextYearAge()}살이며, 
            장래희망은 ${this.futureHope} 입니다.` 
    } 
} 

let kim = new introducePerson('kim','24','seoul', '개발자'); 

console.log(kim.introduce())
```
![ALT](./image/06.png)   
class를 이용할 경우 규칙성을 갖는 객체를 일관성 있게 만드는 게 가능하며, 상속을 통해서 기능 확장이 용이하다는 것 알 수 있었다.

> Reference (opentutorials.org/module/4047/24614developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes)


> 출처: https://ordinary-code.tistory.com/22 [김평범's OrdinaryCode]




## 문제1. 

국어, 영어, 수학 점수를 생성자 파라미터로 입력받아서 합계와 평균을 구하는 클래스 Student를 작성하시오.

이 때 Stuent 클래스는 합계를 리턴하는 메서드인 `sum()`과 평균을 리턴하는 `avg()`를 제공합니다.

작성된 클래스를 활용하여 아래 표에 대한 학생별 합계 점수와 평균점수를 출력하시오.

클래스는 JSON 형식으로 작성되어야 합니다.

| 이름 | 국어 | 영어 | 수학 |
|---|---|---|---|
| 철수 | 92 | 81 | 77 |
| 영희 | 72 | 95 | 98 |
| 민혁 | 80 | 86 | 84 |


#### 출력결과

```
철수의 총점은 249점 이고 평균은 83점 입니다.
영희의 총점은 251점 이고 평균은 83.66666666666667점 입니다.
민혁의 총점은 264점 이고 평균은 88점 입니다.
```

*/




class Student {
    constructor(kor, eng, math) {
        this._kor = kor;
        this._eng = eng;
        this._math = math;
    }


    sum() {
        return this._kor + this._eng + this._math;
    }

    avg() {
        return this.sum() / 3;
    }


};

console.group("반복문 안에서 객체 활용");
const grade = [
    ["철수", 92, 81, 77],
    ["영희", 72, 95, 98],
    ["민혁", 80, 86, 84]
];

for (const item of grade) {
    const s = new Student(item[1], item[2], item[3]);
    console.log("%s의 총점은 %d점 이고 평균은 %d점 입니다.", item[0], s.sum(), s.avg());
}
console.groupEnd();


console.group("하드코딩");
const s1 = new Student(92, 81, 77);
const s2 = new Student(72, 95, 98);
const s3 = new Student(80, 86, 84);
console.log("철수의 총점은 %d점 이고 평균은 %d점 입니다.", s1.sum(), s1.avg());
console.log("영희의 총점은 %d점 이고 평균은 %d점 입니다.", s2.sum(), s2.avg());
console.log("민혁의 총점은 %d점 이고 평균은 %d점 입니다.", s3.sum(), s3.avg());




// ## 문제2.

// 가로(`width`), 세로(`height`)정보를 getter, setter로 관리하는 Rectangle 클래스를 정의하시오.

// 이 클래스는 생성자의 파라미터가 없으며 둘레의 길이를 구해 리턴하는 getAround() 메서드와 넓이를 구해 리턴하는 gerArea() 메서드를 제공합니다.

// 클래스는 JSON 형식으로 작성되어야 합니다.


// #### 출력결과

// 가로가 10이고 세로가 5인 경우

// ```
// 둘레의 길이는 30이고 넓이는 50입니다.
// ```

class Rectangle {
    constructor() {
        this._width = null;
        this._height = null;
    }

    get width() {
        return this._width;
    }

    set width(param) {
        this._width = param;
    }

    get height() {
        return this._height;
    }

    set height(param) {
        this._height = param;
    }

    getAround() {
        return this.width * 2 + this.height * 2;
    }

    getArea() {
        return this.width * this.height;
    }
}


const rect = new Rectangle();
rect.width = 10;
rect.height = 5;

console.log('둘레의 길이는 %d이고 넓이는 %d입니다.', rect.getAround(), rect.getArea());




// 문제 3 - 다음을 만족하는 Student 클래스를 작성하시오.

// 1) String형의 학과와 정수형의 학번을 프로퍼티로로 선언후 생성자를 통해 주입
// 2) getter, setter를 정의
// 3) sayHello() 메서드를 통해 "나는 OOOO학과 OO학번 입니다." 를 출력하는 기능을 구현

class Student {
    constructor(major, num) {
        this._major =  major;
        this._num = num;

    }

    set major(major) {
         this._major = major;
    }

    get major() {
        return this._major;
    }

    set num(num) {
         this._num = num;
    }

    get num() {
        return this._num;
    }

    sayHello(major, num) {
         console.log("나는 %s학과 %d학번이다.", this.major, this.num);
    }
}

const stud1 = new Student("경영", 123456);
stud1.sayHello();



// 문제 - 4. 다음을 만족하는 클래스 Account를 작성하시오.

// 1) 다음의 2 개의 필드를 선언
//     문자열 owner; (이름)
//     숫자형 balance; (금액)
// 2) 위 모든 필드에 대한 getter와 setter의 구현
// 3) 위 모든 필드를 사용하는 가능한 모든 생성자의 구현
// 3) 메소드 deposit()의 헤드는 다음과 같으며 인자인 금액을 저축하는 메소드
//     deposit(amount)
// 4) 메소드 withdraw()의 헤드는 다음과 같으며 인자인 금액을 인출(리턴)하는 메소드
//     withdraw(long amount)
//     인출 상한 금액은 잔액까지로 하며, 이 경우 이러한 상황을 출력





class Account {
    constructor(owner, balance) {
        this._owner = owner;
        this._balance = balance;
    }

    set owner(value) {
         this._owner = value;
    }

    get owner() {
        return this._owner;
    }

    set balance(value) {
         this._balance = value;
    }

    get balance() {
        return this._balance;
    }


    deposit(amount) {
        this._balance += amount;
    }

    withdraw(amount) {
        
        if (this.balance < amount) {
            console.log("잔액이 부족합니다.");
            return 0;
         } 

         this.balance -= amount;
         return amount;
    }

}


const dy = new Account("김도유", 50000);
console.log("%s의 잔액은 %d원", dy.owner, dy.balance);

// 저축 
dy.deposit(20000);
console.log("%s의 잔액은 %d원", dy.owner, dy.balance);

// 인출
dy.withdraw(60000);
console.log("%s의 잔액은 %d원", dy.owner, dy.balance);

// 저축 
dy.deposit(20000);
console.log("%s의 잔액은 %d원", dy.owner, dy.balance);


// 인출
dy.withdraw(250000);
console.log("%s의 잔액은 %d원", dy.owner, dy.balance);



/**
 * isNaN(value)
 * 파라미터로 전달된 값이 NaN일 경우 true, 그렇지 않은 경우 false를 반환한다.
 * -> 숫자가 아니면 true, 숫자가 맞다면 false
 * -> 숫자로 변환 가능한 형식의 경우 false 
 * 
 * JavaScript의 다른 모든 값과 달리, NaN은 같음 연산(==, ===)을 사용해 판별할 수 없다.
 * 그래서 NaN 여부를 판별하는 함수가 필요하다.
 */

// 숫자로 변환할 수 없다고 판단하는 경우
console.log(isNaN(NaN));    //참
console.log(isNaN(undefined));  //참
console.log(isNaN({})); //참
console.log(isNaN('blabla'));
console.log(isNaN('123ABC'));   //참


//  숫자로 변환할 수 있다고 판단하는 경우
console.log(isNaN(true));   // 거짓 --> 1
console.log(isNaN(null));   // 거짓 --> 0
console.log(isNaN(37)); // 거짓
console.log(isNaN('37'));   // 거짓: "37"은 NaN이 아닌 숫자 37로 변환됩니다
console.log(isNaN('')); // 거짓: 빈 문자열은 NaN이 아닌 O으로 변환됩니다
console.log(isNaN(' '));    // 거짓: 공백만으로 구성된 문자열은 NaN이 아닌 0으로 변횐됩니다




/** 
 * parseFloat(value)
 * 
 * 주어진 값에서 변환한 부동소수점 수(실수)를 리턴.
 * 변환할 수 없으면 NaN을 리턴
 
    형 변환
    type casting

    숫자 -> 문자열
    문자열 -> 숫자

    float : 실수
    int : 정수

 */

// 정상적인 경우
console.log(parseFloat(3.14));
console.log(parseFloat('3.14'));
console.log(parseFloat('314e-2'));
console.log(parseFloat('0.0314E+2'));

//NaN을 반환하는 경우
console.log(parseFloat('FF2'));


/** 
 * parseInt(value, int)
 * 
 * 첫번째 파라미터를 10진 정수값으로 변환한다.
 * 변환할 수 없다면 NaN을 반환.
 * 두 번쨰 파라미터는 value가 어떤 진법인지를 알려주는 값.(기본값=10)
 * 문자열의 선행 공백은 무시함
 * 숫자 + 글자 형태의 문자열을 숫자 부분만 취함
 * 글자 + 숫자 형태의 문자열은 변환 불가 - NaN
 * 소수점을 포함하고 있을 경우 정수부분만 취함.
 */


// 10진법 : 0 1 2 3 4 5 6 7 8  9 10 11 12 13 14 15 16 17 18 19 20 21 -> ex) 12
// 16진법 : 0 1 2 3 4 5 6 7 8  9  A  B  C  D  E  F 10 11 12 13 14 15 -> ex) 0x12
// 8진법 : 0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 -> ex) 0o12



// 15로 변환되는 예제들
console.log(parseInt(' 0xF', 16));
console.log(parseInt(' F', 16));
console.log(parseInt('17', 8));
console.log(parseInt('015', 10));       // 따옴표를 제거하고 015는 15와 동일
console.log(parseInt(15.99, 10));       // 소수점 이하는 버림
console.log(parseInt('15,123', 10));    // 콤마(,)는 단순 문자열이므로 콤마 이후는 버려진다.
console.log(parseInt('FXX123', 16));    // 16진수 기준 정상숫자인 F는 인식되지만 문자열 X 이후로는 버려진다.
console.log(parseInt('1111', 2));       
console.log(parseInt('15*3', 10));      // 문자열에서 '*'는 곱하기가 아니라 단순 글자이므로 '*'는 버려진다.
console.log(parseInt('15e2', 10));      // 문자열 'e'이후는 버려진다.
console.log(parseInt('15px', 10));      // 문자열 'px'는 버려진다.


// -15를 반환하는 예제들
console.log(parseInt("-F", 16));
console.log(parseInt("-0F", 16));
console.log(parseInt("-0XF", 16));
console.log(parseInt(-15.1, 10));
console.log(parseInt(" -17", 8));
console.log(parseInt(" -15", 10));
console.log(parseInt("-1111", 2));

// NaN을 반환하는 예제들
console.log(parseInt("Hello", 8));




/**
 * encodeURI(string)
 * 
 * 주어진 문자열을 URL에 포함시키기에 적절한 형태로 변환(=인코딩)하는 처리
 * 인코딩하지 않는 문자
 *  A-Z a-z 0-9 ; , / ? : @ & = + $ - _ . ! ~ * ' ( ) #
 
 https:// search.naver.com/search.naver?where=nexearch&sm=top_hty&fbm=1&ie=utf8&query=자바스크립트
 
 https:// search.naver.com/search.naver?where=nexearch&sm=top_hty&fbm=1&ie=utf8&query=이젠아카데미
 
 [잘못된 경우]
 <a href ="result.html?a=100&b=200&name=자바스크립트">click</a>

 [올바른 경우]

 <a href ="result.html?a=100&b=200&name=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8">click</a>
 * 
 */


const set1 = ';,/?:@&=+$#'; // 예약문자
const set2 = "-_.!~*'()";   // 비예약문자
const set3 = 'ABC abc 123'; // 알파벳 및 숫자, 공백
const set4 = "자바스크립트";


// 특수문자(예약문자 및 비예약문자)를 변환하지 못하기 때문에 UTF-8 환경에서는 사용이 불가
const enc1 = encodeURI(set1);   // ;,/?:@&=+$#
const enc2 = encodeURI(set2);   // -_.!~*'()
const enc3 = encodeURI(set3);   // ABC abc 123
const enc4 = encodeURI(set4);


console.group("encodeURI");
console.log(enc1);
console.log(enc2);
console.log(enc3);
console.log(enc4);
console.groupEnd();

// 인코딩 된 문자열을 원래의 문자열로 역변환 (디코팅)
console.group("decodeURI");
console.log(decodeURI(enc1));
console.log(decodeURI(enc2));
console.log(decodeURI(enc3));
console.log(decodeURI(enc4));
console.groupEnd();




/**
 * encodeURIComponent(string)
 * 
 * 알파벳과 숫자 및 비예약 표식을 제외한 모든 글자를 URL에 포함시킬 수 있는 문자열로 인코딩한다.
 * -> URL에 사용해도 문제가 없는 특수문자를 제외하고 모든 글자를 변환
 */


 const set1 = ';,/?:@&=+$#'; // 예약문자
 const set2 = "-_.!~*'()";   // 비예약문자
 const set3 = 'ABC abc 123'; // 알파벳 및 숫자, 공백
 const set4 = "자바스크립트";
 
 
 // 특수문자(예약문자 및 비예약문자)를 변환하지 못하기 때문에 UTF-8 환경에서는 사용이 불가
 const enc1 = encodeURIComponent(set1);   // ;,/?:@&=+$#
 const enc2 = encodeURIComponent(set2);   // -_.!~*'()
 const enc3 = encodeURIComponent(set3);   // ABC abc 123
 const enc4 = encodeURIComponent(set4);
 
 
 console.group("encodeURI");
 console.log(enc1);
 console.log(enc2);
 console.log(enc3);
 console.log(enc4);
 console.groupEnd();
 
 // 인코딩 된 문자열을 원래의 문자열로 역변환 (디코팅)
 console.group("decodeURI");
 console.log(decodeURIComponent(enc1));
 console.log(decodeURIComponent(enc2));
 console.log(decodeURIComponent(enc3));
 console.log(decodeURIComponent(enc4));
 console.groupEnd();
 
 
 /**
 * setTimeout(func, int)
 * @param - func : 콜백함수
 * @param - int : 1/1000초 단위의 시간값
 * 
 * 지정된 함수를 두 번째 인자로 전달된 시간 후에 실행하도록 예약한다. (딜레이 기능)
 * setTimeout() 이후의 처리 로직들은 func의 실행 여부와 상관없이 즉시 실행된다.
 */

function foo() {
    for (let i=1; i<10; i++) {
        console.log("2 x " + i + " = " + (i*2) );
    }
}

setTimeout(foo, 3000);
console.log("구구단을 외자!!");


// 일반적으로 콜백함수를 별도로 정의하지 않고 즉시 전달한다.\
// setTimeout(function)() {

setTimeout( () => {
    for (let i=1; i<10; i++) {
        console.log("3 x " + i + " = " + (i*3));
    }
}, 1500);

console.log("프로그램 종료~!!");



/**
 * setInterval(func, int)
 * 
 * 지정된 함수를 두 번째 인자로 전달된 시간마다 한 번씩 호출한다.(타미어기능)
 * setInterval() 이후의 처리 로직들은 func의 실행 여부와 상관없이 즉시 실행된다.
 * 
 * 타이머를 종료시킬 수 있는 timerid를 반환한다.
 * 
 * 이 값을 clearInterval() 함수에 전달하면 타이머가 종료한다.
 * 
 * int는 밀리세컨드(1/1000)초를 의미하는 정수
 */

let count1 = 0;

const timerId1 = setInterval(() => {
    count1++;
    console.log("[타이머1] " + count1 + "번째 자동 실행");

    if (count1 == 5) {
        console.log("타이머1 종료");
        clearInterval(timerId1);
    }
}, 3000);

console.log("타이머1 시작");

let count2 = 0;

const timerId2 = setInterval(() => {
   count2++;
   console.log("[타이머2] " + count2 + "번째 자동 실행");

   if(count2 == 10) {
        console.log("타이머2 종료");
        clearInterval(timerId2); 
   }

}, 1000);


console.log("타이머2 시작");




/**
 * [문자열 처리]
 * 
 * 문자열은 그 자체가 객체.
 * 
 * 객체라는 것은 그 안에 멤버변수(프로퍼티)와 메서드(함수)가 내장되어 있음을 의미
 * 
 * 그러므로 일반적으로 생성하는 문자열 변수 안에는 메서드와 프로퍼티가 자동으로 내장된다.
 * 
 * const foo = "Hello World";
 * foo.메서드()
 * 
 * 문자열 객체에 내장된 메서드들은 변수가 담고 있는 내용을 가공하거나 특정 내용을 추출하는 기능을 갖는다.
 * 이 기능들의 공통점은 원본 내용은 절대 변하지 않고, 가공 결과를 리턴한다.
 */

// 변수 형식으로 문자열 만들기
const str1 = "Hello World";
console.log(str1);

// 객체 생성 방식으로 문자열 만들기
const str2 = new String("Hello Javascript");
console.log(str2);

// 기능을 확인하기 위한 문자열의 선언
const msg = "Life is too short, You need Javascript.";
console.log("문자열 : " + msg);

// 문자열의 글과 수를 가져온다.
// --> 공백과 특수문자 포함
const len = msg.length;
console.log("문자열의 길이 : " + len);


// 파라미터로 설정된 위치의 글자를 리턴한다.
// --> 위치는 0부터 카운트
const str2nd = msg.charAt(2);
console.log("두 번째 글자 : " + str2nd);

// 모든 문자열은 그 자체로 배열처럼 취급될 수 있다. 
console.log("두 번째 글자 : " + msg[2]);

// 파라미터로 전달된 내용이 처음 나타나는 위치를 리턴한다.
const p1 = msg.indexOf("f");
console.log("'f'가 처음 나타나는 위치 : " + p1);

// 찾지 못할 경우 -1을 반환함
console.log("'z'가 처음 나타나는 위치 : " + msg.indexOf("z") );

// 단어나 문장으로 검색할 경우 일치하는 내용이 시작되는 첫 글자의 위치를 반환
console.log("'short'가 처음 나타나는 위치 : " + msg.indexOf("short"));

// indexOf에 파라미터가 두 개인 경우, 
// 두 번째 숫자 값은 첫 번째 파라미터의 글자를 찾기 시작하는 위치를 의미한다.
const p2 = msg.indexOf("i");
const p3 = msg.indexOf("i", p2+1);
console.log("'i'가 첫 번째로 나타나는 위치 : " + p2);
console.log("'i'가 두 번째로 나타나는 위치 : " + p3);

// 파라미터로 전달된 글자가 마지막으로 나타나는 위치를 리턴한다.
// 단 이 위치를 문자열의 끝에서 부터 새는 것이 아니라 문자열의 처음부터 샌다.
// 찾지 못할 경우 -1을 반환
const msg = "Life is too short, You need Javascript.";
const p4 = msg.lastIndexOf("a");
console.log("'a'의 마지막 위치 : " + p4);

// 응용
if (msg.indexOf("Hello") > -1) {
    console.log("Hello가 포함됨");
} else {
    console.log("Hello가 포함되지 않음.");
}

// 잘라내기 위한 시작 위치와 끝 위치를 파라미터로 설정한다.
// 지정된 끝 위치의 직전 글자까지만 잘라낸다.
const msg = "Life is too short, You need Javascript.";
const substring1 = msg.substring(0, 17);
console.log("문자열 자르기 : " + substring1);

// 두 번째 파라미터가 없을 경우 지정된 위치부터 끝까지 자른다.
const msg = "Life is too short, You need Javascript.";
const substring2 = msg.substring(19);
console.log("문자열 자르기 : " + substring2);

// 모든 글자를 대문자로 변환한다.
const up = msg.toUpperCase();
console.log("모든 글자의 대문자 변환 : " + up);

// 모든 글자를 소문자로 변환한다.
const low = msg.toLowerCase();
console.log("모든 글자를 소문자 변환 : " + low);

// 문자열의 앞/뒤 공백 지우기
const src1 = "  Hello World  ";
const src2 = src1.trim();
console.log(src1);
console.log(src2);

// 문자열에 포함된 구분자를 기준으로 문자열을 잘라 배열로 반환한다.
const txt = "HTML,CSS,Javascript";
const arr = txt.split(",");
console.log(arr);

// 첫 번째 파라미터의 내용을 두 번째 파라미터로 변경한 결과를 반환한다.
// 첫 번째 파라미터와 일치하는 내용이 둘 이상 존재할 경우 첫 번째 항목만 변경한다.
const txt2 = txt.replace(",", "$");
console.log(txt2);

const test = "Hello Javascript, World Javascript";
console.log(test.replaceAll("Javascript", "자바스크립트"));






/**
 * Math
 * 수학적인 속성과 메서드를 가진 내장 객체
 * 모든 기능이 정적 멤버변수와 정적 메서드 형태를 제공된다.
 * 즉, 객체 생성을 하지 않고 클래스 이름으로 직접 접근한다.
 */

/**(1) 주어진 값 중에서 최대값 (파라미터 수 제한 없음) */
var max = Math.max(100, 123, 456, 789, 1000);
console.log("최대값: " + max);

/**(2) 주어진 값 중에서 최소값 (파라미터 제한 없음) */
var min = Math.min(100, 123);
console.log("최소값: " + min);

/** (3) 소수점 반올림 */
var num1 = 3.7146;
console.log("소수점 반올림: " + Math.round(num1));

/** (4) 소수점 올림과 내림 */
console.log("소수점 올림: " + Math.ceil(num1));
console.log("소수점 내림: " + Math.floor(num1));

/** (5) 절대값을 반환 */
var num2 = -123;
console.log("절대값 : " + Math.abs(num2));

/** (6) 0~1 범위의 난수 발생 */
console.log("난수: " + Math.random());

/** 두 수 사이의 난수 리턴하는 함수 */
function random(n1, n2) {
    return parseInt(Math.random() * (n2 - n1 + 1)) + n1;
}

/** 함수의 결과 확인 */
var rnd = random(0, 9);
console.log("0~9 사이의 난수:" + rnd);

/** 함수의 응용 >> 5자리 인증번호 생성 */
var auth = "";
for (var i=0; i<5; i++) {
    // 문자열과 숫자의 결합은 문자열 결합과 같다.
    auth += random(0, 9);
}

console.log("인증번호: " + auth);



/** 
 * Date
 * 객체를 생성하는 순간의 시스템 시각이나 생성자 파라미터로 전달된 시작을 플랫폼에 종속되지 않는 형태로 나타낸다.
 */

/** 요일의 이름을 저장하고 있는 배열의 생성 */
const days = ['일', '월', '화', '수', '목', '금', '토'];

/** 객체의 생성 */
const date1 = new Date();

/** 년, 월, 일 시간, 분, 초를 리턴받기*/
const yy = date1.getFullYear();
// 월은 0이 1월 11이 12월을 의미한다.
const mm = date1.getMonth() + 1;
const dd = date1.getDate();

// 0=일요일 ~6=토요일의 값이 리턴된다.
const i = date1.getDay();
const day = days[i];

const hh = date1.getHours();
const mi = date1.getMinutes();
const ss = date1.getSeconds();

var result = yy + '-' + mm + '-' + dd + ' ' + day + '요일 ' + hh + ':' + mi + ':' + ss;
console.log(result);

/** 날짜를 의미하는 문자열 반환하기 */
// 날짜 부분만 나타내는, 사람이 읽을 수 있는 문자열을 반환
const date1 = new Date();
console.log(date1.toDateString());

// Date를 나타내는 문자열 ISO 8601 확장 형식에 맞춰 반환
console.log(date1.toISOString());

// 형식 문자열을 사용해서 Date를 나타내는 문자열을 생성
const date1 = new Date();
console.log(date1.toLocaleString());
console.log(date1.toLocaleString('de-DE'));
console.log(date1.toLocaleString('ko-KR'));

// Date의 날짜 부분을 나타내는 문자열을 시스템에 설정된 현재 지역의 형식으로 반환
const date1 = new Date();
console.log(date1.toLocaleDateString());
console.log(date1.toLocaleDateString('de-DE'));
console.log(date1.toLocaleDateString('ko-KR'));


// Date의 시간 부분을 나타내는 문자열을 시스템에 설정된 현재 지역의 형식으로 반환
console.log(date1.toLocaleTimeString());
console.log(date1.toLocaleTimeString('de-DE'));
console.log(date1.toLocaleTimeString('ko-KR'));

/** 특정 날짜를 의미하는 객체 생성 */
// 시각이 없으므로 자정으로 설정된다.
var date2 = new Date(2021, 9, 5);
console.log(date2.toLocaleString('ko-KR'));

/** 특정 시점을 의미하는 객체 생성 */
var date3 = new Date(2021, 9, 5 , 21, 19, 31);
console.log(date3.toLocaleString('ko-KR'));

/** 이미 생성된 날짜 객체의 성분 변경 */
date3.setYear(2010);
date3.setMonth(1); // 0부터 시작하므로 2월을 위해서는 1로 설정한다.
date3.setDate(14);
date3.setHours(12);
date3.setMinutes(16);
date3.setSeconds(30);
console.log(date3.toLocaleString('ko-KR'));






/** 날짜계산 */

// timestamp 확인하기
// timestamp -> 1970년 1월 1일 자정부터 현재까지 흐른 시간을 초단위로 환산한 값.
// get Time()함수는 timestamp를 밀리세컨드단위로 환산하여 반환한다
const date = new Date();
const ts1 = date.getTime();
console.log(ts1);

// 몇일이 지났는지 계산하기
const prevDay = new Date(date.getFullYear(), 0, 1);
const ts2 =  prevDay.getTime();
const tmp1 = ts1 - ts2;
// 계산 결과를 원하는 단위로 환산 --> 24시간 * 60분 * 60초 * 1000
// 과거의 시점으로부터 지나온 시간을 계산할 경우 소수점을 내린다.
const day1 = Math.floor(tmp1 / (24 * 60 * 60 * 1000));
console.log("올해는 " + day1 + "일 지났습니다.");

// 몇일이 남았는지 계산하기
const nextDay = new Date(date.getFullYear(), 11, 31);
const ts3 = nextDay.getTime();
const tmp2 = ts3 - ts1;
// 미래의 시점으로 남은 시간을 계산할 경우 소수점을 올린다.
const day2 = Math.ceil(tmp2 / (24 * 60 * 60 * 1000));
console.log("올해는 " + day2 + "일 남았습니다.");

// 지금으로부터 30일 후
// 단위가 수용할 수 있는 값이 초과될 경우 자동으로 올림 처리한다.
const a = date.getDate() + 30;
date.setDate(a);
console.log(date.toLocaleString('ko-KR'));

// 30일 지난 후에서 다시 100일 전을 계산
const b = date.getDate() - 100;
date.setDate(b);
console.log(date.toLocaleString('ko-KR'));

/** 응용 */
// 오늘 날짜 객체
const today = new Date();
// 이번달의 1일로 이동
today.setDate(1);
// 이번달 1일에 대한 요일 인덱스
const startDay = today.getDay();
console.log(startDay);

// 이번달의 마지막날은 몇일인지 구함. -> 다음달의 0번째 날짜를 구함.
const m = today.getMonth();
today.setMonth(m+1);
today.setDate(0);
const lastDate =  today.getDate();
console.log(lastDate);

// 6행 7열의 빈 배열 만들기
var data = new Array(6);
for (let i=0; i<data.length; i++) {
    data[i] = new Array(7);
}

// 1씩 증가할 값
let counter = 1;

for (let i=0; i<data.length; i++) {
    for (let j=0; j<data[i].length; j++) {
        if (i == 0 && j < startDay || counter > lastDate) {
            data[i][j] = 0;
        } else {
            data[i][j] = counter++;
        }
    }
}

for (let i=0; i<data.length; i++) {
    let str = '';
    for (let j=0; j<data[i].length; j++) {
        str += data[i][j] == 0 ? " \t" : (data[i][j] + "\t");
    }
    console.log(str);
}




/** 
 * Number는 숫자 처리와 관련된 기본 기능들을 제공하는 내장 클래스.
 */

// 객체의 생성
var a = new Number(123); // a === 123은 false
console.log(a);
console.log(typeof a);
console.log(a == 123);
console.log(a === 123);

// Number() 함수를 통해 반환받는 값은 객체가 아닌 일반 숫자
// Number() 함수는 parseFloat, parseInt와 비슷한 기능.
var b = Number('123'); // b === 123은 true
console.log(b);
console.log(typeof b);
console.log(b === 123);

var b = Number('123.45'); // b === 123은 true
console.log(b);
console.log(typeof b); //false
console.log(b === 123.45);

/** (정적)속성 */
// 표현 가능한 가장 큰 양수.
console.log(Number.MAX_VALUE);

// 표현 가능한 가장 작은 양수. 즉, 0보다 크지만 0에 가장 가까운 양수.
console.log(Number.MIN_VALUE);

// "숫자가 아님"을 나타내는 특별한 값.
console.log(Number.NaN);
console.log(isNaN(Number.NaN));

/** (정적)메서드 */
// 주어진 값이 NaN인지 확인 (isNaN과 동일)
// 숫자 변환이 불가능하면 true, 가능하면 false
console.log(Number.isNaN('123'));

// 주어진 값이 정수 인지 확인
console.log(Number.isInteger('123'));
console.log(Number.isInteger(123));

// 내장 함수 parseFloat()와 동일
// 앞에서 소개한 Number() 함수와 동일
console.log(Number.parseFloat('123'));

// 내장 함수 parseInt()와 동일
console.log(Number.parseInt('123'));




/**
 * 정규표현식
 * 문자열의 형식을 의미하는 수식.
 * 문자열이 특정 조건을 충족하는지 검사하거나 특정 패턴의 문자열을 검색, 치환 하기 위해 사용함.
 * 
 * 
 * const 변수명 = /정규표현식/
 * 변수명.test(검사할 문자열) --> 문자열이 정규표현식에 부합할 경우 true를 반환함.
 */

// 회원가입시 입력받은 값을 가정한 변수
// 사용자가 입력한 모든 내용은 문자열 변수이다.
const username = "자바스크립트";
const age ='20';
const userid = 'js123';

// 이름의 한글 입력 검사
const pattern1 = /^[ㄱ-ㅎ가-힣]*$/;
// username이 pattern1 정규식에 부합하지 않는다면?
if (!pattern1.test(username)) {
    console.log('이름은 한글만 입력 가능합니다.');
}

// 나이의 숫자 입력 검사
const pattern2 = /^[0-9]*$/;
if (!pattern2.test(userid)) {
    console.log('아이디는 영어+숫자 조합으로만 입력 가능합니다.');
}

// 아이디의 영문+숫자 검사
const pattern3 = /^[a-zA-Z0-9]*$/;
if (!pattern3.test(userid)) {
    console.log('아이디는 영어+숫자 조합으로만 입력 가능합니다.');
}

// 아이디의 최대 글자 수 검사
if (userid.length > 20) {
    console.log('아이디는 최대 20자 까지만 입력 가능합니다.');
}

console.log('검사완료!!');


/** 
 * 배열의 원소를 추가, 삭제, 변경하는 방법
 */

// 테스트를 위한 배열
const data = [10, 20, 30, 40, 50];

// 배열의 맨 끝에 요소 추가 (파라미터 수 제한 없음.)
data.push(60, 70);
console.log(data); // -> [10, 20, 30, 40, 50, 60, 70]

// 마지막 요소를 리턴하고 제거
const k = data.pop();
console.log(k); // -> 70
console.log(data); // -> [10, 20, 30, 40, 50, 60]

// 맨 앞 요소를 리턴하고 제거
const x = data.shift();
console.log(x); // ->10
console.log(data); // -> [20, 30, 40, 50, 60]

// 맨 앞에 요소 추가 (파라미터 제한 없음)
data.unshift(0, 10);
console.log(data); // -> [0., 10, 20, 30, 40, 50, 60]

// 2번째 위치부터 3개를 잘라서 반환하고 원본에서는 제거
const z = data.splice(2, 3);
console.log(z); // -> [20, 30, 40]
console.log(data); // -> [0, 10, 50, 60]

// 0번째 위치부터 2개를 제거하고 그 위치에 다른 요소들을 배치함
// 제거한 수보다 추가되는 원소수가 많을 경우 배열이 확장됨. 기존의 원소들은 뒤로 밀림.
// 제어한 수보다 추가되는 원소수가 적을 경우 축소됨.
data.splice(0, 2, 'a', 'b', 'c');
console.log(data); // -> ['a', 'b'', 'c', 50, 60]

// 삭제할 원소의 수를 0으로 지정하면 중간 삽인 효과가 있음.
// 기존의 원소들은 뒤로 밀려남.
data.splice(3, 0, 'd', 'e');
console.log(data); // ->['a', 'b'', 'c'', 'd', 'e', 50, 60]

// a에  b와 c를 결합한 새로운 배열을 반환
const a = [1, 2];
const b = [3, 4, 5];
const c = [6, 7, 8, 9];
const d = a.concat(b, c);
console.log(d); // -> [1,2,3,4,5,6,7,8,9]



/** 1) 배열 탐색하기 */
let arr1 = [1, 0, false];

// arr.indexOf(item, from)는 인덱스 from부터 시작해 item(요소)을 찾는다.
// 요소를 발견하면 해당 요소의 인덱스를 반환한다.
// arr.lastIndexOf(item, from)는 위 메서드와 동일한 기능을 하는데, 검색을 끝에서부터 시작한다.
// 두 번째 파라미터 (from)이 없으면 처음부터 탐색한다.
console.log( arr1.indexOf(0) ); // 1
console.log( arr1.indexOf(false) ); // 2
// 발견하지 못했으면 -1을 반환한다.\
console.log( arr1.indexOf(null) ); // -1

// arr.includes(item, from)는 인덱스 from 부터 시작해 item이 있는지를 검색하는데, 해당하는 요소를 발견하면 true를 반환한다.
console.log( arr1.includes(1) ); //true
console.log( arr1.includes(100) ); // false

//위 메서드들은 요소를 찾을 때 완전 항등 연산자 === 을 사용한다는 점에 유의해야 한다.
// false를 검색하면 정확히 false만을 검색하지, 0을 검색하진 않는다.
// 요소의 위치를 정확히 알고 싶은게 아니고 요소가 배열 내 존재하는지 여부만 확인하고 싶다면 arr.includes를 사용하는 게 좋다.
// includes는 NaN도 제대로 처리한다는 점에서 indexOf/lastIndexOf와 약간의 차이가 있다.
const arr2 = [NaN];
console.log( arr1.indexOf(NaN) ); // -1 (완전 항등 비교 ===는 NaN에 동작하지 않으므로 0이 출력되지 않는다.)
console.log( arr1.includes(NaN) ); // true (NaN의 여부를 확인한다.)

/** 배열 검색 */
const arr3 = [5, 12, 8, 131, 44];

// 주어진 판별함수를 만족하는 첫번째 값을 반환한다. 못찾으면 undefined를 반환한다.
// 찾고자 하는 항목이 아닌 검색 규칙을 구현한 콜백함수를 전달해야 한다.
const found = arr3.find(function(v){
    // 파라미터로 전달되는 v는 배열의 모든 원소가 순차적으로 전달된다.
    console.log(v);    

    // v를 우리가 원하는 조건에 충족하느지 검사하여 true/false를 리턴
    // true를 리턴하는 순간 배열의 탐색을 중단한다. (break와 동일한 기능)
    if (v % 2 == 0) {
        // true가 리턴되는 경우 v는 found에 저장된다.
        return true;
    } else {
        // false가 리턴되는 경우 v는 버려진다.
        return false;
    }
});

console.log(found);

/** 배열 전체 검색 */
const arr4 = [5, 12, 8, 131, 44];
const results = arr4.filter(function(v, i, arr){
    console.log("v=%d, i=%d, arr=%s", v, i, arr);

    if (v % 2 == 0) {
        // true가 리턴되는 경우 v는 results 배열의 원소로 저장된다.
        // true를 리턴하더라도 배열의 모든 원소를 탐색하기 전까지는 종료되지 않는다.
        return true;
    } else {
        // false가 리턴되는 경우 v는 버려진다.
        return false;
    }
});

console.log(results);

/** 배열 정렬 */
const arr5 = [2, 1, 15];
// 퀵정렬 알고리즘을 사용하여 배열 자체를 정렬한다.
// --> 배열의 모든 원소를 문자열로 취급하기 때문에 글자 정렬기준이 적용된다.
// arr5.sort();
// console.log(arr5);

// sort 함수도 정렬 조건을 콜백함수로 처리한다.
arr5.sort(function(a, b) {
    // 정렬을 위해 비교되는 원소값들이 파라미터로 전달된다.
    console.log("a=%s, b=%s", a, b);

    // 리턴값이 양수인 경우: a가 b보다 크다
    // 리턴값이 음수인 경우: b가 a보다 크다
    if (a > b) {
        return 1;
    } else {
        return -1;
    }
});

console.log(arr5);

/** 역순배치 */
let arr6 = [1, 2, 3, 4, 5];
arr6.reverse();
console.log(arr6);



/** 
 * 배열을 탐색하는 방법
 */

// 테스트를 위한 배열
const arr = [10, 20, 30, 40, 50];

/**
 * 배열에 대한 반복 처리(1) - 배열의 원소 스캔하기
 */
for (let i=0; i<arr.length; i++) {
    if (i == 3) {
        console.log(" ~~~ 반복중단!!!");
        break;
    }
    console.log("%d번째 원소 ==> %d", i, arr[i]);
}

console.log("----------------------");

// 콜백함수에게 배열의 값과 인덱스를 전달한다.
// 콜백함수는 원소의 수 만큼 순차적으로 실행된다.
arr.forEach((v, i) => {
    if (i == 3) {
        console.log(" ~~~반복중단!!!");
        // 콜백함수 역시 함수 이므로 break를 사용해서 중단할 수 있다.
        // break;
        // forEach의 콜백함수에서 반복을 중단하고자 return을 사용할 경우 현재 동작중인 콜백만 종료될 뿐 전체 반복에는 영향이 없다.
        return;
    }
    console.log("%d번째 원소 ==> %d", i, v);
});

console.log("---------------");


/**
 * 배열에 대한 반복 처리(2) - 탐색 중단
 */
arr.some((v, i)=>{
    // some 함수는 콜백함수가 true를 리턴하는 순간 순환을 중단한다.
    if (i == 3) {
        console.log(" ~~~반복중단!!!");
        return true;
    }
    console.log("%d번째 원소 ==> %d", i, v);
});

console.log("-----------------");


/**
 * 배열에 대한 반복 처리(3) - 콜백함수에서 리턴하는 값들을 하나의 배열로 묶기
 */
// 전통적인 방법
const d1 = [];
for (let i=0; i<arr.length; i++) {
    // 배열의 맨 뒤에 새로운 윈소 추가 ==> 확장
    if (arr[i] % 4 == 0) {
        d1.push(arr[i]);
    }
}

console.log(d1);


// forEach를 사용하는 방법
const d2 = [];
arr.forEach((v, i) => {
    if (v % 4 == 0) {
        d2.push(v);
    }
});
console.log(d2);

// map함수에 전달된 콜백이 리턴하는 값들을 하나의 배열로 묶어서 hello에 저장
// const hello = arr.map( function(v, i) {
//    return v+1;
// });


// 콜백 함수를 화살표 함수로 변환(ES6)
// const hello = arr.map( (v, i) => {
//     return v + 1;
// });

// 화살표 함수는 처리로직이 한줄인 경우 "{}"와 ";", "return" 키워드 생략 가능함
const hello = arr.map( (v, i) => v +1 );

// --> Array(5) [20, 30, 40, 50, 60]
console.log(hello);

// ## 문제1.

// 자신의 이메일 주소를 `email` 이라는 변수에 저장하고 `@`를 기준으로 아이디와 도메인 부분을 분리하여 출력하시오.


// ### 출력결과

// 이메일이 leekh4232@gmail.com 인 경우

// ```
// leekh4232
// gmail.com
// ```



email = "leekh4232@gmail.com";

p = email.indexOf("@");
id = email.substring(0,p);
domain = email.substring(p+1);

console.log(id);
console.log(domain);


// ## 문제2.

// 임의의 주민번호를 다음과 같이 `*`을 포함하여 변수에 저장하시오.

// ```
// ssn = '020517-3******'
// ```

// 또한 현재 년도를 now_year라는 변수로 저장하시오.

// 이 값을 사용하여 생년월일, 나이, 성별을 출력하시오.

// #### 출력결과

// ```
// 2002년 5월 17일에 태어난 20세 남자 입니다.
// ```



/// 강사님 풀이
const ssn = '020517-3******';

const date = new Date();
const now_year = date.getFullYear();

let yy = parseInt(ssn.substring(0, 2));
let mm = parseInt(ssn.substring(2, 4));
let dd = parseInt(ssn.substring(4, 6));
let gen = parseInt(ssn.substring(7, 8));

//console.log("%d, %d, %d, %d",yy, mm, dd, gen);

// 2000년도 이전 출생자의 주민번호 뒷자리 -> 1,2
// 2000년도 이후 출생자의 주민번호 뒷자리 -> 3,4


yy = (gen > 2) ? yy+2000 : yy+1900;
//console.log(yy);

// 나이 계산
const age = now_year - yy + 1;
//console.log(age);


// 성별 확인
const sex = (gen % 2) ? "남자" : "여자";
//console.log(sex);
/** 
 * const k = 조건 ? A:B;
 * 조건이 참(true)이면 k에 A가 저장됨 
 * 조건이 거짓(false)이면 k에 B가 저장됨.
 * 
 * true를 숫자로 환산하면 0이 아닌 모든 수.
 * false를 숫자로 환산하면 0
 * 
 * 숫자 % 2 --> 이 연산식의 결과값 범위 0, 1
 */


// if (gen % 2 == 0) {
//     if (gen == 2 || gen == 4) {
//         sex ="여자";
//     } else {
//         sex = "남자";
//     }
// }

console.log("%d년 %d월 %d일에 태어난 %d세 %s 입니다.", yy, mm, dd, age, sex);


// ## 문제3.

// 아래의 문장에서 "수업시간"이라는 단어가 총 몇 번 등장하는지 카운트 하는 프로그램을 구현하시오.

// ```
// str = "수업시간에 배운것은 수업시간에 다 이해하고 넘어가야지 수업시간에 놓치면 따라오기 힘들다."
// ```

// #### 출력결과

// ```
// 3
// ```



str = "수업시간에 배운것은 수업시간에 다 이해하고 넘어가야지 수업시간에 놓치면 따라오기 힘들다.";

word ="수업시간";
flen = word.length;
find = true;
count = 0;

while(find) {
    console.log(str);
    p = str.indexOf(word);
    find = p > -1; 

    if (find) {
        count++;
        str = str.substring(p+flen);
    }
}


console.log(count);

// ## 문제4. (로또번호 생성기 1)

// 주어진 범위 안에서 랜덤한 숫자를 추출하는 함수는 아래와 같다.

// ```javascript
// function random(n1, n2) {
//     return parseInt(Math.random() * (n2 - n1 + 1)) + n1;
// }
// ```

// 0개의 원소를 갖는 배열 `lotto`를 생성하고 6회의 반복을 수행하는 for문을 사용하여 배열의 각 원소를 `1~45` 사이의 범위를 갖는 임의의 숫자로 채워 넣으시오.

// 반복이 종료되었을 때 `lotto`의 원소는 6개의 숫자가 채워져 있어야 하고 각 숫자는 중복되지 않아야 합니다.

// 중복되지 않는 숫자를 생성하기 위해 for문 안에서 무한반복을 위한 while문을 수행해야 합니다.



/** 랜덤함수 */
function random(n1, n2) {
    return parseInt(Math.random() * (n2 - n1 + 1)) + n1;
}

// 0개의 원소를 갖는 배열
const lotto = [];
console.log(lotto);

// 6회의 반복을 수행
for (let i=0; i<6; i++) {
    console.group("%d번째 원소 결정하기", i);
    console.log("%s", lotto);
    // 중복되지 않는 숫자가 몇 번째에 생성될 지 알 수 없으므로 무한반복
    while(true) {
        // 랜덤한 숫자
        const rnd = random(1, 45);

        // rnd값이 lotto배열안의 원소와 중복되지 않는다면?
        if (!lotto.includes(rnd)) {
            console.log(">>> %d는 중복되지 않음", rnd);
            lotto.push(rnd);
            break;
        } else {
            console.log(">>> %d는 중복됨", rnd);
        }
    }
    console.groupEnd();
}

console.log(lotto);


// ## 문제5. (로또번호 생성기 2)

// `1~45`사이의 범위의 1씩 증가 하는 원소가 저장되어 있는 배열 `balls`을 생성하고 6개의 빈 칸을 갖는 배열 `lotto`를 생성하시오.

// `lotto` 배열을 탐색하는 반복을 수행하면서 `balls` 배열에서 임의의 원소 하나를 추출하여 `lotto` 배열에 채워 넣으시오.

// 추출된 숫자는 `balls` 배열에서는 삭제되어야 합니다.


// 강사님 풀이

function random(n1, n2) {
    return parseInt(Math.random() * (n2 - n1 + 1)) + n1;
}


// '1~45'사이의 범위의 1씩 증가 하는 원소가 저장되어 있는 배열 'balls'을 생성
const balls = new Array(45);  

for (let i=0; i<balls.length; i++) {
    balls[i] = i+1;
}

//console.log(balls);

// 6개의 빈 칸을 갖는 배열 'lotto'를 생성
const lotto = new Array(6);

for (let i=0; i<lotto.length; i++) {
    
   console.log(balls);

    // balls의 index범위 안에서 임의의 위치를 선정
    const rnd = random(0, balls.length-1);

    // 'balls' 배열에서 임의의 원소 하나를 추줄하여 'lotto' 배열에 채워넣기
    lotto[i] = balls[rnd];
 
    // rnd번째 위치에서 하나의 데이터를 잘라냄
    balls.splice(rnd, 1);
   
}


console.log(lotto);



// ## 문제6.

// 수많은 마라톤 선수들이 마라톤에 참여하였습니다. 
// 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

// 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 
// 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 
// 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.

// ```javascript
// function solution(participant, completion) {
//     var answer = '';
//     return answer;
// }
// ```

// ### 제한사항

// - 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
// - completion의 길이는 participant의 길이보다 1 작습니다.
// - 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
// - 참가자 중에는 동명이인이 있을 수 없습니다.

// ### 입출력 예

// | participant | completion | return |
// |---|---|---|
// | ["leo", "kiki", "eden"] | ["eden", "kiki"] | "leo" |
// | ["marina", "josipa", "nikola", "vinko", "filipa"] | ["josipa", "filipa", "marina", "nikola"] | "vinko" |
// | ["mislav", "stanko", "steave", "ana"] | ["stanko", "ana", "mislav"] | "steave |

// ```javascript
// // "leo"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.
// // 출력결과: "leo"가 출력
// console.log(solution(["leo", "kiki", "eden"], 
//                      ["eden", "kiki"]));

// // "vinko"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.
// // 출력결과: "vinko"가 출력
// console.log(solution(["marina", "josipa", "nikola", "vinko", "filipa"], 
//                      ["josipa", "filipa", "marina", "nikola"]));

// // "steave"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.
// // 출력결과: "steave"가 출력
// console.log(solution(["mislav", "stanko", "steave", "ana"], 
//                      ["stanko", "ana", "mislav"]));
// ```




// 강사님 풀이 
function solution(participant, completion) {
    var answer = '';

    // participant 원소 중에서 completion에 포함되지 않은 하나의 원소를 찾아서 answer에 저장하는 것이 문제 내용.
    // --> participant의 원소를 탐색하여 completion에 속하지 않음을 확인하면 그 순간 반복 중단

/** 1) for문을 사용하다 탐색하다가 break 사용 */
//     for (let i=0; i<participant.length; i++) {
//         const p = participant[i];
        
//         // i번째 원소가 completion에 들어 있다면?
//         if (!completion.includes(p)) {
//             answer = p;
//             break;
//         }
//     }

//     return answer;
// }


/** 2) 배열의 some함수 사용 */
participant.some((v, i)=>{
        if(!completion.includes(v)) {
            answer = v;
            return true;
        }
    });

    return answer;
}

console.log(solution(["leo", "kiki", "eden"], 
                     ["eden", "kiki"])+"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.");

console.log(solution(["marina", "josipa", "nikola", "vinko", "filipa"], 
                     ["josipa", "filipa", "marina", "nikola"])+"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.");


console.log(solution(["mislav", "stanko", "steave", "ana"], 
                     ["stanko", "ana", "mislav"])+"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.");





















## 비동기처리란?
특정 로직의 실행이 끝날때까지 기다려주지 않고 나머지 코드를 먼저 실행하는것을 비동기 처리라고 한다.

비동기처리가 필요한 이유는 화면에서 서버로 데이터를 요청했을때 서버가 언제 그 요청에대한 응답을 줄지 모르는데 마냥 기다릴순 없기 때문이다.

>간단한 비동기 처리 예제
```javascript
// #1
console.log('Hello');
// #2
setTimeout(function() {
	console.log('Bye');
}, 3000);
// #3
console.log('Hello Again');
```

위코드로 다음과같은 출력결과를 기대했지만

- ‘Hello’ 출력
- 3초 있다가 ‘Bye’ 출력
- ‘Hello Again’ 출력


setTimeout() 역시 비동기방식으로 처리되기때문에 실제로는 다음과같이 실행된다.

- ‘Hello’ 출력
- ‘Hello Again’ 출력
- 3초 있다가 ‘Bye’ 출력

> 출처 : https://velog.io/@zayong/%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC

동기 --> 순차작업   
비동기 --> 비순차작업

## Promise가 뭔가요?
“A promise is an object that may produce a single value some time in the future”

프로미스는 자바스크립트 비동기 처리에 사용되는 객체입니다. 여기서 자바스크립트의 비동기 처리란 ‘특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하는 자바스크립트의 특성’을 의미합니다.

 ### 프로미스의 3가지 상태(states)
프로미스를 사용할 때 알아야 하는 가장 기본적인 개념이 바로 프로미스의 상태(states)입니다. 여기서 말하는 상태란 프로미스의 처리 과정을 의미합니다. new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖습니다.

- Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태
- Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태
- Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태

#### Pending(대기)
먼저 아래와 같이 new Promise() 메서드를 호출하면 대기(Pending) 상태가 됩니다.

```javascript
new Promise();
```

`new Promise()` 메서드를 호출할 때 콜백 함수를 선언할 수 있고, 콜백 함수의 인자는 resolve, reject입니다.

```javascript
new Promise(function(resolve, reject) {
  // ...
});
```
#### Fulfilled(이행)
여기서 콜백 함수의 인자 resolve를 아래와 같이 실행하면 이행(Fulfilled) 상태가 됩니다.

```javascript
new Promise(function(resolve, reject) {
  resolve();
});
```

그리고 이행 상태가 되면 아래와 같이 then()을 이용하여 처리 결과 값을 받을 수 있습니다.

```javascript
function getData() {
  return new Promise(function(resolve, reject) {
    var data = 100;
    resolve(data);
  });
}

// resolve()의 결과 값 data를 resolvedData로 받음
getData().then(function(resolvedData) {
  console.log(resolvedData); // 100
});
```

#### Rejected(실패)
`new Promise()`로 프로미스 객체를 생성하면 콜백 함수 인자로 `resolve`와 `reject`를 사용할 수 있다고 했습니다. 여기서 `reject`를 아래와 같이 호출하면 실패(Rejected) 상태가 됩니다.

```javascript
new Promise(function(resolve, reject) {
  reject();
});
```
그리고, 실패 상태가 되면 실패한 이유(실패 처리의 결과 값)를 catch()로 받을 수 있습니다.

```javascript
function getData() {
  return new Promise(function(resolve, reject) {
    reject(new Error("Request is failed"));
  });
}

// reject()의 결과 값 Error를 err에 받음
getData().then().catch(function(err) {
  console.log(err); // Error: Request is failed
});
```

![ALT](promise.svg)

> 출처: https://joshua1988.github.io/web-development/javascript/promise-for-beginners/

# 동기식 (Synchronous) / 비동기식 (Asynchronous)

## 동기식 (Synchronous)
먼저 시작된 하나의 작업이 끝날 때까지 다른 작업을 시작하지 않고 기다렸다가 다 끝나면 새로운 작업을 시작하는 방식이다.
위 그림 `Synchronous`와 같이 작업이 직렬로 배치되어 실행되며 작업 실행의 순서가 확실히 정해져 있는 것을 `동기식 처리`라 부른다.

## 비동기식 (Asynchronous)
동기식 방식과는 다르게 먼저 시작된 작업의 완료 여부와는 상관없이 새로운 작업을 시작하는 방식이다.
위 그림 `Asynchronous`와 같이 작업이 병렬로 배치되어 실행되며 작업의 순서가 확실하지 않아 나중에 시작된 작업이 먼저 끝나는 경우도 발생한다.
이와 같은 방식을 `비동기식 처리`라 부른다.

# 자바스크립트 비동기 처리
자바스크립트에는 아래와 같이 3가지 `비동기 처리방식`이 있다.

1. 콜백 함수 사용
1. Promise
1. Promise를 활용한 async/await


자바스크립트는 기본적으로 비동기적으로 동작을 한다.
개발하다 보면 비동기식으로 동작하는 부분이 동기적으로 동작해야 하는 경우가 생긴다.
이럴 때 비동기식 동작이 동기식으로 동작하도록 해주는 걸 `비동기 처리`라고 한다.

각 방식들을 하나씩 알아보도록 하자.

## 1. 콜백 함수 사용
- 콜백 함수를 사용하지 않을 경우
```javascript
// 콜백 함수
function printString(callbackParam) {
  console.log(callbackParam);
}

// 콜백 함수 호출
function callHello() {
  let value;
  
  console.log("Wait 3 sec.");
  console.log('waiting...');
  
  setTimeout(function() {
    value = 'Hello';
  }, 3000);
  
  return value;
}

// 실행
const r = callHello();
printString(r);
```
- 결과
```javascript
# 시작
Wait 3 sec.
waiting...
undefined
(3초 대기)
# 종료
```
위에서 말했듯 자바스크립트는 비동기적으로 동작하기 때문에 `callHello()`의 결괏값이 `r`로 전달되기 전에 `printString(r)`을 실행하게 되면서 `undefined`가 출력된다.
그리고 그 후 `setTimeout()`에 의해서 3초 대기 후 종료하게 된다.

-----
- 콜백 함수를 사용할 경우

```javascript 
// 콜백 함수
function printString(callbackParam) {
  console.log(callbackParam);
}

// 콜백 함수 호출
function printString(callbackParam) {
  console.log(callbackParam);
}

function callPrint(callback) {
  let value;
  
  console.log("Wait 3 sec.");
  console.log("waiting...");
  
  setTimeout(function() {
    value = "Hello";
    callback(value);
  }, 3000);
}

// 실행
callPrint(printString);
```
- 결과

```javascirpt
# 시작
Wait 3 sec.
waiting...
(3초 대기)
Hello
# 종료
```

콜백 함수를 사용하면 위 결과에서 볼 수 있듯이 `setTimeout()`에 의해 3초간 대기 후 `콜백 함수`로 전달된 `printString()`을 실행하여 `Hello`를 출력하게 된다.

----

그러나 위의 예제와 다르게 실제로 개발을 하다 보면 `콜백 함수`가 복잡해지는 경우가 많아진다.
소위 말하는 `콜백 지옥(Callback hell)`에 빠지는 경우가 생길 수 있다.
```javascript
a(function (resultsFromA) {
  b(resultsFromA, function (resultsFromB) {
    c(resultsFromB, function (resultsFromC) {
      d(resultsFromC, function (resultsFromD) {
        e(resultsFromD, function (resultsFromE) {
          f(resultsFromE, function (resultsFromF) {
            console.log(resultFromF);
          })    
        })
      })
    })
  })
});
```

이렇듯 `콜백 함수`를 남용하게 되면 `가독성`과 `에러 처리` 등에서 불편함이 발생한다.
이를 해소하기 위해 `ES6`에서 비동기 처리의 새로운 방법으로 `Promise 객체`가 등장한다.


## 2. Promise
> The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.(번역: Promise 개체는 비동기 작업의 최종 완료 (또는 실패)와 그 결과 값을 나타낸다.)  출처 MDN Web Docs


Promise는 자바스크립트 비동기 처리에 사용되는 객체이다.
이를 사용하면 비동기 작업이 종료된 이후의 성공 결괏값이나 실패에 대하여 처리할 수 있다.

'Promise'는 자바스크립트 비동기 처리에 사용되는 객체이다.
이를 사용하면 비동기 작업이 종료된 이후의 '성공 결괏값'이나 '실패'에 대하여 처리할 수 있다.


- Promise 처리 흐름
![ALT](image.png)
> 출처 MDN Web Docs

Promise는 다음 중 하나의 상태를 가진다.

- 대기(pending): 이행하거나 거부되지 않은 초기 상태
- 이행(fulfilled): 연산이 성공적으로 완료됨
- 거부(rejected): 연산이 실패함


### Promise 사용 방법
```javascript
new Promise(function(resolve, reject) {
  // ...
});
```
`new Promise()` 객체를 생성하여 `콜백 함수`를 선언할 수 있는데 이때의 인자는 `resolve, reject`를 사용한다.
`resolve`는 결과가 성공인 `Promise 객체`를 반환하고 `reject`는 결과가 실패인 `Promise 객체`를 반환한다.

반환된 `Promise 객체`를 처리할 때 성공 시 `then`을 사용하고 실패 시 `catch`를 사용하여 처리한다.



### Promise 사용 예시
- 성공 예시
```javascript
let myFirstPromise = new Promise((resolve, reject) => {
  setTimeout(function(){
    // 성공 시 resolve 사용
    resolve(`Success!`);
  }, 3000);
});

// 성공 시 then 사용하여 결과 처리
myFirstPromise.then((successMessage) => {
  console.log(`Yay! ` + successMessage);
});
```

- 결과
```javascript
# 시작
(3초 대기)
Yay! Success!
# 종료
```

- 실패 예시
```javascript
let myFirstPromise = new Promise((resolve, reject) => {
  setTimeout(function(){
    // 실패 시 resolve 사용
    reject(new Error(`Fail!`));
  }, 3000);
});

// reject를 사용하여 Promise 객체를 반환하기 때문에 then은 실행되지 않는다.
myFirstPromise.then((successMessage) => {
  console.log(`Yay! ` + successMessage);
})
// 실패 시 catch 사용하여 결과 처리
.catch((reason) => {
  console.log('여기서 거부된 프로미스( ' + reason + ' )를 처리하세요.');
});
```

- 결과
```javascript
# 시작
(3초 대기)
여기서 거부된 프로미스( Error: Fail )를 처리하세요.
# 종료
```


### 그렇다면 Promise 방식이 콜백 함수보다 좋은 점이 무엇일까?
바로 위에서 말했던 콜백 지옥을 해결할 수 있는 방식이기 때문이다.
```javascript
function a() {
  return new Promise({
    // ...
  });
}

function b() {
  return new Promise({
    // ...
  });
}

function c() {
  return new Promise({
    // ...
  });
}

myFirstPromise()
.then(a)
.then(b)
.then(c);
```

`콜백 함수`를 사용했으면 훨씬 길어지고 복잡해졌을 코드도 위 예시와 같이 `Promise 객체`를 반환하면 여러 개의 `then`을 연결하여 간단히 처리할 수 있다.



## 3. Promise를 활용한 async/await
`ES2017`에 새로 추가된 `async/await`는 위에서 알아봤던 `Promise 객체`를 기반으로 사용한다.
위 `Promise` 설명의 마지막에서 말했듯이 `Promise` 대신 쓰는 새로운 방식이 아니라 `Promise`를 다른 방식으로 사용하는 내용이기 때문에 `Promise`에 대한 개념을 익히고 와야 이해할 수 있다.

Promise에 대하여 충분히 이해됐다면 함께 async/await를 알아보도록 하자.

 ### 기존 Promise와의 차이점
가장 큰 차이점은 위에서 배웠던 `resolve`, `reject`, `then`, `c`atch`를 쓰지 않는다는 것이다.



사실 async/await만 사용하려면 저 4가지는 어떻게 사용했는지 잊어버려도 된다.

하지만 위에서 알아본 Promise 객체에 대한 내용을 전혀 모른 채로 왔다면 async/await를 이해하는 데에 더 머리가 아팠을 것이다.

__*이미 충분히 개념을 익혀온 여러분은 아주 짧은 설명만으로도 async/await를 이해하고 사용하는 데에 어려움이 없을 것이다!*__


### async
- async 사용 예시
```javascript
// async 키워드만 붙이면 된다.
async function hello() {
  return 'Hello';
}

function callHello() {
  const r = hello();
  console.log(r); 
}

callHello();
```

- 결과
```javascript
# 시작
Promise { 'Hello' }
# 끝
```
놀랍게도 위에서 사용했던 `new Promise()`고 뭐고 아무것도 없다.
그냥 기본 메소드 앞에 `async`만 붙이면 반환되는 값이 `Promise 객체`가 된다.
`Promise 객체`가 무엇인지는 이미 익히고 온 여러분은 이 간단한 예시만으로 `async`를 어떻게 쓰는지 이해가 다 됐을 거라 생각된다.

그런데 우리는 위 예시처럼 객체 형태의 `Promise { 'Hello' }`가 아니라 그 안에 있는 String 형태의 `Hello`를 출력하고 싶다.

어떻게 해야 할까??
다음 설명을 보도록 하자.
----
### await
이제 우리는 async를 어떻게 쓰는지 또 어떤 결과가 나오는지는 알고 있다.
이번엔 그 결과를 어떻게 내가 원하는 방식으로 사용할지를 알아보도록 하겠다.

- await 사용 예시
```javascript
async function hello() {
  return 'Hello';
}

// (2) 새로 추가된 async 키워드
async function callHello() {
  // (1) 새로 추가된 await 키워드
  const r = await hello();
  console.log(r);
}

callHello();
```

- 결과
```javascript 
# 시작
Hello
# 끝
```
자 달라진 내용을 살펴보자.
먼저 `(1)` 부분을 보면 `hello();` 앞에 `await` 키워드가 추가됐다.
`await`가 붙으면 반환된 `Promise 객체`에서 실제 `hello()` 메소드의 반환 값인 `String 값`을 뽑아낸다고 보면 된다.
그렇다면 위 예시의 `r` 값에 String 형태의 `Hello`가 입력될 것이다.
출력 결과를 보면 `await`가 붙기 전이랑 다르게 `r`을 출력하면 `문자열`만 출력되는 걸 확인 할 수 있다.

다음은 `(2)` 부분을 보면 `callHello()`메소드에도 `async`가 추가됐다.
`await` 키워드는 `async` 키워드가 붙은 메소드에서만 사용할 수 있다.
만약 `async`가 없는 메소드에서 `await`를 사용한다면 아래와 같은 `SyntaxError`가 발생한다.

![ALT](image%20(1).png)

### 결과 처리방법
위 내용은 굉장히 쉬워서 이해하는 데에 어려움이 없었을 것 같다.

하지만 아직 끝난 게 아니다.

이제 우리는 성공과 실패에 대해 처리를 해서 마무리를 지어줘야 하는데 기존 `Promise` 방식으로 생각하면 `then`, `catch` 부분을 처리해줘야 한다.
당연히 이 부분도 훨씬 쉽다.

위에서 사용한 예시를 활용하여 바로 알아보자!

- 성공 처리 예시
```javascript
async function hello() {
  return 'Hello';
}

async function callHello() {
  // 새로 추가된 try 키워드
  try {
    const r = await hello();
    console.log('성공: ' + r);
  } catch (e) {
    console.log('실패: ' + e.message);
   }
}

callHello();
```

- 결과
```javascript
# 시작
성공: Hello
# 끝
```

- 실패 처리 예시
```javascript
async function hello() {
  throw new Error(`Fail!`);
}

async function callHello() {
  try {
    const r = await hello();
    console.log(r);
    // 새로 추가된 catch 키워드
  } catch (e) {
    console.log(e.message);
   }
}

callHello();
```
- 결과
```javascript
# 시작
실패: Fail!
# 끝
```

기존 then과 catch는 각각 try-catch로 바뀌었다.
위 예시와 같이 await를 붙인 메소드의 결과가 성공일 경우는 try 부분이 실행되고 실패일 경우는 catch 부분이 실행된다.
이 내용은 기존 C언어나 Java언어 등에서 사용하는 try-catch 개념과 비슷하기 때문에 별다른 설명 없이도 충분히 이해가 될 거라 생각한다.

여기까지 자바스크립트의 3가지 비동기 처리 방법에 대해서 알아봤다.



> 출처: https://velog.io/@change/JavaScript-asyncawait%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C


/**
 * 시나리오.
 * 
 * 1초 후 "당신의 추첨 결과는...?" 이라는 메시지 표시
 * 1~9에 대한 랜덤값이 짝수이면 당첨, 홀수이면 꽝
 * 그 결과를 3초 후에 표시
 * 
 * 타이머에 대한 작업 종료 후 이어서 새로운 타이머를 만들어 진행
 */
function random(n1, n2) {
    return parseInt(Math.random() * (n2 - n1 + 1)) + n1;
}

setTimeout(() => {
    console.log("당신의 추첨 결과는...?");
    const lucky = random(1, 9);
    setTimeout(() => {
        //console.log(lucky);
        console.log(lucky % 2 == 0 ? "당첨입니다~!!" : "꽝!!!");
    }, 3000);
}, 1000);

console.log("추첨중~~~");




/** 
 * 비동기 처리로 실행되는 함수에 대한 결과 처리를 별도의 로직으로 실행할 수 있는 기법
 */
 function random(n1, n2) {
    return parseInt(Math.random() * (n2 - n1 + 1)) + n1;
}

// Promise를 가동하기 위해서는 Promise객체를 리턴하는 함수가 필요함.
function getLuckyResult() {
    // Promise객체는 resolve 함수와, reject 함수를 파라미터로 받는 콜백이 필요함.
    return new Promise(function (resolve, reject){
        // 이 안에서 비동기 작업을 시작함.
        setTimeout(() =>{
            console.log("당신의 추첨 결과는...?");
            const lucky = random(1, 9);

            if (lucky % 2 == 0) {
                // 작업의 결과가 성공으로 판별된 경우 resolve()를 호출함
                // 파라미터는 단 하나만 가능.
                // 여러 개의 정보를 보내야 하는 경우 JSON 구조가 적절
                resolve({msg: "당첨입니다~!!", a: 1, b:2, c:3});
            } else {
                // 작업의 결과가 실패로 판별된 경우 reject()을 호출함
                reject({msg: "꽝~!!", d: -1, e: -2});
            }
        }, 1000);

    });
}

/** Promise객체를 리턴받기 위한 함수를 호출 */
// getLuckyResult()함수 내부에서 Promise객체가 생성되면서,
// Promise 클래스에 전달한 생성자 파라미터(콜백함수)가 실행될 것이다.
// --> resolve 혹은 reject 가 호출된 상태라는 의미
const mypromise = getLuckyResult();

/** Promise객체가 생성되는 과정에서 생정자로 전달된 콜백함수의 실행 결과를 감지하는 부분 */
// --> resolve  혹은 reject 중에서 실행된 함수가 무엇인지 감지
// --> 비동기 작업의 결과를 알아냄
// --> 타이머 종료에 이은 후속처리가 가능하다는 의미.
mypromise.then(({msg, a, b, c}) => {
    // [작업성공] -> resolve() 실행됨
    console.log("%s, a=%d, b=%d, c=%d", msg, a, b, c);
}). catch(({msg, d, e}) =>{
    // [작업실패] -> reject() 실행됨
    console.error('%s, d=%d, e=%d', msg, d, e);
}). finally(() => {
    // 성공 실패 여부에 상관 없이 무조건 실행되는 마무리 처리
    // 생략 가능
    console.log("fin :)");
});





function random(n1, n2) {
    return parseInt(Math.random() * (n2 - n1 + 1)) + n1;
}


function getLuckyResult() {
    // Promise객체는 resolve 함수와, reject 함수를 파라미터로 받는 콜백이 필요함.
    return new Promise(function (resolve, reject){
        // 이 안에서 비동기 작업을 시작함.
        setTimeout(() =>{
            console.log("당신의 추첨 결과는...?");
            const lucky = random(1, 9);
            if (lucky % 2 == 0) {             
                resolve({msg: "당첨입니다~!!", a: 1, b:2, c:3});
            } else {
                reject({msg: "꽝~!!", d: -1, e: -2});
            }
        }, 1000);

    });
}

// Promise를 리턴하는 함수를 호출하기 위해 새로운 async 함수를 정의
// 주로 즉시 실행 함수 형태로 정의됨.
// -> 익명함수 전체를 괄호()로 묶어버리고 그 뒤에 호출을 위한 ()를 연달아 넣는 형식
// (async function() {)
(async () => {
    let result = null;

    //Promise를 리턴받는 과정을 await 키워드를 적용하여 처리, 예외처리도 적용
    try {
        result = await getLuckyResult();
        console.log("%s, a=%d, b=%d, c=%d", result.msg, result.a, result.b, result.c);
    } catch (e) {
        // getLuckyResult에서 reject()가 호출되면서 전달한 파라미터는 예외객체(e)로 전달
        console.error('%s, d=%d, e=%d', e.msg, e.d, e.e);
        }
})();




/**
    1. Sysntax Error : 문법에러. 코딩상의 실수이므로 수정하지 않으면 프로그램이 동작하지 않음.
    2. Runtime Error : 프로그램 작성 과정에서 논리상의 오류로 미처 대응하지 못한 상황이 발생하는 경우.
        -> 처리하지 않을 경우 프로그램이 중단된다.
 */


/** 기본적인 에러 핸들링 */
const data = [1, 2, 3];

console.log('배열 탐색 시작');

// 먼저, try {...} 안의 코드가 실행된다.
// 에러가 없다면, try 안의 마지막 줄까지 실행되고, catch 블록은 건너뛴다.
// 에러가 있다면, try 안 코드의 실행이 중단되고, catch(err) 블록으로 제어 흐름이 넘어간다.
// 변수 err(아무 이름이나 사용 가능)는 무슨 일이 일어났는지에 대한 설명이 담긴 에러 객체를 포함한다.

try {
    for (let i = 0; i < 10; i++) {
        console.log(data[i].toFixed(2));
    }

    console.log("try 블록 실행 완료~!!!");
} catch (err) {
    console.group('%s 에러발생', err.name);
    console.error(err.message);
    console.groupEnd();
    // 에러정보 전체
    // console.error(err);
} finally {
    // 에러의 발생 여부에 상관 없이 무조건 맨 마지막에 실행되는 블록.
    // 필요하지 않은 경우 생략할 수 있다.
    console.log("배열 탐색이 종료되었습니다.");
}

// try ~ catch로 발생할 에러에 대비하면 에러가 발생하더라도 프로그램이 중단되지 않는다.
console.log('프로그램 종료');




